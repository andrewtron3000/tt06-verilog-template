//
// Generated by Bluespec Compiler, version 2024.01-1-g4d953407 (build 4d953407)
//
// On Thu Apr 11 20:25:11 EDT 2024
//
//
// Ports:
// Name                         I/O  size props
// RDY_startup_value              O     1
// txrx_SOUT                      O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// startup_value_v                I     8
// txrx_SIN                       I     1 reg
// EN_startup_value               I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkRule30Driver(CLK,
		      RST_N,

		      startup_value_v,
		      EN_startup_value,
		      RDY_startup_value,

		      txrx_SIN,

		      txrx_SOUT);
  input  CLK;
  input  RST_N;

  // action method startup_value
  input  [7 : 0] startup_value_v;
  input  EN_startup_value;
  output RDY_startup_value;

  // action method txrx_sin
  input  txrx_SIN;

  // value method txrx_sout
  output txrx_SOUT;

  // signals for module outputs
  wire RDY_startup_value, txrx_SOUT;

  // inlined wires
  wire uart_pwRecvCellCountReset$whas,
       uart_pwRecvEnableBitCount$whas,
       uart_pwRecvResetBitCount$whas,
       uart_pwXmitCellCountReset$whas,
       uart_pwXmitEnableBitCount$whas,
       uart_pwXmitLoadBuffer$whas;

  // register a
  reg [7 : 0] a;
  wire [7 : 0] a$D_IN;
  wire a$EN;

  // register transmit_state
  reg [1 : 0] transmit_state;
  wire [1 : 0] transmit_state$D_IN;
  wire transmit_state$EN;

  // register uart_fifoRecv_countReg
  reg [1 : 0] uart_fifoRecv_countReg;
  wire [1 : 0] uart_fifoRecv_countReg$D_IN;
  wire uart_fifoRecv_countReg$EN;

  // register uart_fifoXmit_countReg
  reg [1 : 0] uart_fifoXmit_countReg;
  wire [1 : 0] uart_fifoXmit_countReg$D_IN;
  wire uart_fifoXmit_countReg$EN;

  // register uart_rRecvBitCount
  reg [3 : 0] uart_rRecvBitCount;
  wire [3 : 0] uart_rRecvBitCount$D_IN;
  wire uart_rRecvBitCount$EN;

  // register uart_rRecvCellCount
  reg [3 : 0] uart_rRecvCellCount;
  wire [3 : 0] uart_rRecvCellCount$D_IN;
  wire uart_rRecvCellCount$EN;

  // register uart_rRecvData
  reg uart_rRecvData;
  wire uart_rRecvData$D_IN, uart_rRecvData$EN;

  // register uart_rRecvParity
  reg uart_rRecvParity;
  wire uart_rRecvParity$D_IN, uart_rRecvParity$EN;

  // register uart_rRecvState
  reg [2 : 0] uart_rRecvState;
  reg [2 : 0] uart_rRecvState$D_IN;
  wire uart_rRecvState$EN;

  // register uart_rXmitBitCount
  reg [3 : 0] uart_rXmitBitCount;
  wire [3 : 0] uart_rXmitBitCount$D_IN;
  wire uart_rXmitBitCount$EN;

  // register uart_rXmitCellCount
  reg [3 : 0] uart_rXmitCellCount;
  wire [3 : 0] uart_rXmitCellCount$D_IN;
  wire uart_rXmitCellCount$EN;

  // register uart_rXmitDataOut
  reg uart_rXmitDataOut;
  reg uart_rXmitDataOut$D_IN;
  wire uart_rXmitDataOut$EN;

  // register uart_rXmitParity
  reg uart_rXmitParity;
  wire uart_rXmitParity$D_IN, uart_rXmitParity$EN;

  // register uart_rXmitState
  reg [2 : 0] uart_rXmitState;
  reg [2 : 0] uart_rXmitState$D_IN;
  wire uart_rXmitState$EN;

  // register uart_vrRecvBuffer_0
  reg uart_vrRecvBuffer_0;
  wire uart_vrRecvBuffer_0$D_IN, uart_vrRecvBuffer_0$EN;

  // register uart_vrRecvBuffer_1
  reg uart_vrRecvBuffer_1;
  wire uart_vrRecvBuffer_1$D_IN, uart_vrRecvBuffer_1$EN;

  // register uart_vrRecvBuffer_2
  reg uart_vrRecvBuffer_2;
  wire uart_vrRecvBuffer_2$D_IN, uart_vrRecvBuffer_2$EN;

  // register uart_vrRecvBuffer_3
  reg uart_vrRecvBuffer_3;
  wire uart_vrRecvBuffer_3$D_IN, uart_vrRecvBuffer_3$EN;

  // register uart_vrRecvBuffer_4
  reg uart_vrRecvBuffer_4;
  wire uart_vrRecvBuffer_4$D_IN, uart_vrRecvBuffer_4$EN;

  // register uart_vrRecvBuffer_5
  reg uart_vrRecvBuffer_5;
  wire uart_vrRecvBuffer_5$D_IN, uart_vrRecvBuffer_5$EN;

  // register uart_vrRecvBuffer_6
  reg uart_vrRecvBuffer_6;
  wire uart_vrRecvBuffer_6$D_IN, uart_vrRecvBuffer_6$EN;

  // register uart_vrRecvBuffer_7
  reg uart_vrRecvBuffer_7;
  wire uart_vrRecvBuffer_7$D_IN, uart_vrRecvBuffer_7$EN;

  // register uart_vrXmitBuffer_0
  reg uart_vrXmitBuffer_0;
  wire uart_vrXmitBuffer_0$D_IN, uart_vrXmitBuffer_0$EN;

  // register uart_vrXmitBuffer_1
  reg uart_vrXmitBuffer_1;
  wire uart_vrXmitBuffer_1$D_IN, uart_vrXmitBuffer_1$EN;

  // register uart_vrXmitBuffer_2
  reg uart_vrXmitBuffer_2;
  wire uart_vrXmitBuffer_2$D_IN, uart_vrXmitBuffer_2$EN;

  // register uart_vrXmitBuffer_3
  reg uart_vrXmitBuffer_3;
  wire uart_vrXmitBuffer_3$D_IN, uart_vrXmitBuffer_3$EN;

  // register uart_vrXmitBuffer_4
  reg uart_vrXmitBuffer_4;
  wire uart_vrXmitBuffer_4$D_IN, uart_vrXmitBuffer_4$EN;

  // register uart_vrXmitBuffer_5
  reg uart_vrXmitBuffer_5;
  wire uart_vrXmitBuffer_5$D_IN, uart_vrXmitBuffer_5$EN;

  // register uart_vrXmitBuffer_6
  reg uart_vrXmitBuffer_6;
  wire uart_vrXmitBuffer_6$D_IN, uart_vrXmitBuffer_6$EN;

  // register uart_vrXmitBuffer_7
  reg uart_vrXmitBuffer_7;
  wire uart_vrXmitBuffer_7$D_IN, uart_vrXmitBuffer_7$EN;

  // ports of submodule rule30
  wire [7 : 0] rule30$getResult, rule30$start_a;
  wire rule30$EN_getResult,
       rule30$EN_start,
       rule30$RDY_getResult,
       rule30$RDY_start;

  // ports of submodule uart_baudGen_rBaudCounter
  wire [15 : 0] uart_baudGen_rBaudCounter$DATA_A,
		uart_baudGen_rBaudCounter$DATA_B,
		uart_baudGen_rBaudCounter$DATA_C,
		uart_baudGen_rBaudCounter$DATA_F,
		uart_baudGen_rBaudCounter$Q_OUT;
  wire uart_baudGen_rBaudCounter$ADDA,
       uart_baudGen_rBaudCounter$ADDB,
       uart_baudGen_rBaudCounter$SETC,
       uart_baudGen_rBaudCounter$SETF;

  // ports of submodule uart_baudGen_rBaudTickCounter
  wire [2 : 0] uart_baudGen_rBaudTickCounter$DATA_A,
	       uart_baudGen_rBaudTickCounter$DATA_B,
	       uart_baudGen_rBaudTickCounter$DATA_C,
	       uart_baudGen_rBaudTickCounter$DATA_F,
	       uart_baudGen_rBaudTickCounter$Q_OUT;
  wire uart_baudGen_rBaudTickCounter$ADDA,
       uart_baudGen_rBaudTickCounter$ADDB,
       uart_baudGen_rBaudTickCounter$SETC,
       uart_baudGen_rBaudTickCounter$SETF;

  // ports of submodule uart_fifoRecv
  wire [7 : 0] uart_fifoRecv$D_IN;
  wire uart_fifoRecv$CLR,
       uart_fifoRecv$DEQ,
       uart_fifoRecv$EMPTY_N,
       uart_fifoRecv$ENQ;

  // ports of submodule uart_fifoXmit
  wire [7 : 0] uart_fifoXmit$D_IN, uart_fifoXmit$D_OUT;
  wire uart_fifoXmit$CLR,
       uart_fifoXmit$DEQ,
       uart_fifoXmit$EMPTY_N,
       uart_fifoXmit$ENQ,
       uart_fifoXmit$FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_compute,
       CAN_FIRE_RL_dump_rx,
       CAN_FIRE_RL_get_result,
       CAN_FIRE_RL_uart_baudGen_assert_2x_baud_tick,
       CAN_FIRE_RL_uart_baudGen_baud_count_wire,
       CAN_FIRE_RL_uart_baudGen_baud_tick_count_wire,
       CAN_FIRE_RL_uart_baudGen_count_baudtick_16x,
       CAN_FIRE_RL_uart_baud_generator_clock_enable,
       CAN_FIRE_RL_uart_fifoRecv__updateLevelCounter,
       CAN_FIRE_RL_uart_fifoXmit__updateLevelCounter,
       CAN_FIRE_RL_uart_receive_bit_cell_time_counter,
       CAN_FIRE_RL_uart_receive_bit_counter,
       CAN_FIRE_RL_uart_receive_buffer_shift,
       CAN_FIRE_RL_uart_receive_find_center_of_bit_cell,
       CAN_FIRE_RL_uart_receive_parity_bit,
       CAN_FIRE_RL_uart_receive_sample_pin,
       CAN_FIRE_RL_uart_receive_stop_first_bit,
       CAN_FIRE_RL_uart_receive_stop_last_bit,
       CAN_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample,
       CAN_FIRE_RL_uart_receive_wait_for_start_bit,
       CAN_FIRE_RL_uart_transmit_bit_cell_time_counter,
       CAN_FIRE_RL_uart_transmit_bit_counter,
       CAN_FIRE_RL_uart_transmit_buffer_load,
       CAN_FIRE_RL_uart_transmit_buffer_shift,
       CAN_FIRE_RL_uart_transmit_send_parity_bit,
       CAN_FIRE_RL_uart_transmit_send_start_bit,
       CAN_FIRE_RL_uart_transmit_send_stop_bit,
       CAN_FIRE_RL_uart_transmit_send_stop_bit1_5,
       CAN_FIRE_RL_uart_transmit_send_stop_bit2,
       CAN_FIRE_RL_uart_transmit_shift_next_bit,
       CAN_FIRE_RL_uart_transmit_wait_1_bit_cell_time,
       CAN_FIRE_RL_uart_transmit_wait_for_start_command,
       CAN_FIRE_startup_value,
       CAN_FIRE_txrx_sin,
       WILL_FIRE_RL_compute,
       WILL_FIRE_RL_dump_rx,
       WILL_FIRE_RL_get_result,
       WILL_FIRE_RL_uart_baudGen_assert_2x_baud_tick,
       WILL_FIRE_RL_uart_baudGen_baud_count_wire,
       WILL_FIRE_RL_uart_baudGen_baud_tick_count_wire,
       WILL_FIRE_RL_uart_baudGen_count_baudtick_16x,
       WILL_FIRE_RL_uart_baud_generator_clock_enable,
       WILL_FIRE_RL_uart_fifoRecv__updateLevelCounter,
       WILL_FIRE_RL_uart_fifoXmit__updateLevelCounter,
       WILL_FIRE_RL_uart_receive_bit_cell_time_counter,
       WILL_FIRE_RL_uart_receive_bit_counter,
       WILL_FIRE_RL_uart_receive_buffer_shift,
       WILL_FIRE_RL_uart_receive_find_center_of_bit_cell,
       WILL_FIRE_RL_uart_receive_parity_bit,
       WILL_FIRE_RL_uart_receive_sample_pin,
       WILL_FIRE_RL_uart_receive_stop_first_bit,
       WILL_FIRE_RL_uart_receive_stop_last_bit,
       WILL_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample,
       WILL_FIRE_RL_uart_receive_wait_for_start_bit,
       WILL_FIRE_RL_uart_transmit_bit_cell_time_counter,
       WILL_FIRE_RL_uart_transmit_bit_counter,
       WILL_FIRE_RL_uart_transmit_buffer_load,
       WILL_FIRE_RL_uart_transmit_buffer_shift,
       WILL_FIRE_RL_uart_transmit_send_parity_bit,
       WILL_FIRE_RL_uart_transmit_send_start_bit,
       WILL_FIRE_RL_uart_transmit_send_stop_bit,
       WILL_FIRE_RL_uart_transmit_send_stop_bit1_5,
       WILL_FIRE_RL_uart_transmit_send_stop_bit2,
       WILL_FIRE_RL_uart_transmit_shift_next_bit,
       WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time,
       WILL_FIRE_RL_uart_transmit_wait_for_start_command,
       WILL_FIRE_startup_value,
       WILL_FIRE_txrx_sin;

  // inputs to muxes for submodule ports
  reg [2 : 0] MUX_uart_rRecvState$write_1__VAL_3;
  wire [2 : 0] MUX_uart_rRecvState$write_1__VAL_1,
	       MUX_uart_rRecvState$write_1__VAL_2,
	       MUX_uart_rRecvState$write_1__VAL_4,
	       MUX_uart_rXmitState$write_1__VAL_1,
	       MUX_uart_rXmitState$write_1__VAL_2,
	       MUX_uart_rXmitState$write_1__VAL_3,
	       MUX_uart_rXmitState$write_1__VAL_4,
	       MUX_uart_rXmitState$write_1__VAL_5,
	       MUX_uart_rXmitState$write_1__VAL_6,
	       MUX_uart_rXmitState$write_1__VAL_7;
  wire MUX_transmit_state$write_1__SEL_1,
       MUX_uart_rRecvState$write_1__SEL_6,
       MUX_uart_rXmitDataOut$write_1__SEL_1,
       MUX_uart_rXmitDataOut$write_1__SEL_2,
       MUX_uart_rXmitDataOut$write_1__SEL_3;

  // remaining internal signals
  wire [3 : 0] x__h2951, x__h4655, x__h6411, x__h6437;
  wire _dor2uart_pwXmitCellCountReset$EN_wset,
       uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29,
       z__h7894,
       z__h7901,
       z__h7908,
       z__h7915,
       z__h7922,
       z__h7929;

  // action method startup_value
  assign RDY_startup_value = transmit_state == 2'd0 ;
  assign CAN_FIRE_startup_value = transmit_state == 2'd0 ;
  assign WILL_FIRE_startup_value = EN_startup_value ;

  // action method txrx_sin
  assign CAN_FIRE_txrx_sin = 1'd1 ;
  assign WILL_FIRE_txrx_sin = 1'd1 ;

  // value method txrx_sout
  assign txrx_SOUT = uart_rXmitDataOut ;

  // submodule rule30
  mkRule30 rule30(.CLK(CLK),
		  .RST_N(RST_N),
		  .start_a(rule30$start_a),
		  .EN_start(rule30$EN_start),
		  .EN_getResult(rule30$EN_getResult),
		  .RDY_start(rule30$RDY_start),
		  .getResult(rule30$getResult),
		  .RDY_getResult(rule30$RDY_getResult));

  // submodule uart_baudGen_rBaudCounter
  Counter #(.width(32'd16), .init(16'd0)) uart_baudGen_rBaudCounter(.CLK(CLK),
								    .RST(RST_N),
								    .DATA_A(uart_baudGen_rBaudCounter$DATA_A),
								    .DATA_B(uart_baudGen_rBaudCounter$DATA_B),
								    .DATA_C(uart_baudGen_rBaudCounter$DATA_C),
								    .DATA_F(uart_baudGen_rBaudCounter$DATA_F),
								    .ADDA(uart_baudGen_rBaudCounter$ADDA),
								    .ADDB(uart_baudGen_rBaudCounter$ADDB),
								    .SETC(uart_baudGen_rBaudCounter$SETC),
								    .SETF(uart_baudGen_rBaudCounter$SETF),
								    .Q_OUT(uart_baudGen_rBaudCounter$Q_OUT));

  // submodule uart_baudGen_rBaudTickCounter
  Counter #(.width(32'd3),
	    .init(3'd0)) uart_baudGen_rBaudTickCounter(.CLK(CLK),
						       .RST(RST_N),
						       .DATA_A(uart_baudGen_rBaudTickCounter$DATA_A),
						       .DATA_B(uart_baudGen_rBaudTickCounter$DATA_B),
						       .DATA_C(uart_baudGen_rBaudTickCounter$DATA_C),
						       .DATA_F(uart_baudGen_rBaudTickCounter$DATA_F),
						       .ADDA(uart_baudGen_rBaudTickCounter$ADDA),
						       .ADDB(uart_baudGen_rBaudTickCounter$ADDB),
						       .SETC(uart_baudGen_rBaudTickCounter$SETC),
						       .SETF(uart_baudGen_rBaudTickCounter$SETF),
						       .Q_OUT(uart_baudGen_rBaudTickCounter$Q_OUT));

  // submodule uart_fifoRecv
  SizedFIFO #(.p1width(32'd8),
	      .p2depth(32'd3),
	      .p3cntr_width(32'd1),
	      .guarded(1'd1)) uart_fifoRecv(.RST(RST_N),
					    .CLK(CLK),
					    .D_IN(uart_fifoRecv$D_IN),
					    .ENQ(uart_fifoRecv$ENQ),
					    .DEQ(uart_fifoRecv$DEQ),
					    .CLR(uart_fifoRecv$CLR),
					    .D_OUT(),
					    .FULL_N(),
					    .EMPTY_N(uart_fifoRecv$EMPTY_N));

  // submodule uart_fifoXmit
  SizedFIFO #(.p1width(32'd8),
	      .p2depth(32'd3),
	      .p3cntr_width(32'd1),
	      .guarded(1'd1)) uart_fifoXmit(.RST(RST_N),
					    .CLK(CLK),
					    .D_IN(uart_fifoXmit$D_IN),
					    .ENQ(uart_fifoXmit$ENQ),
					    .DEQ(uart_fifoXmit$DEQ),
					    .CLR(uart_fifoXmit$CLR),
					    .D_OUT(uart_fifoXmit$D_OUT),
					    .FULL_N(uart_fifoXmit$FULL_N),
					    .EMPTY_N(uart_fifoXmit$EMPTY_N));

  // rule RL_dump_rx
  assign CAN_FIRE_RL_dump_rx = uart_fifoRecv$EMPTY_N ;
  assign WILL_FIRE_RL_dump_rx = uart_fifoRecv$EMPTY_N ;

  // rule RL_compute
  assign CAN_FIRE_RL_compute = rule30$RDY_start && transmit_state == 2'd1 ;
  assign WILL_FIRE_RL_compute = CAN_FIRE_RL_compute ;

  // rule RL_uart_baudGen_baud_count_wire
  assign CAN_FIRE_RL_uart_baudGen_baud_count_wire = 1'd1 ;
  assign WILL_FIRE_RL_uart_baudGen_baud_count_wire = 1'd1 ;

  // rule RL_uart_baud_generator_clock_enable
  assign CAN_FIRE_RL_uart_baud_generator_clock_enable = 1'd1 ;
  assign WILL_FIRE_RL_uart_baud_generator_clock_enable = 1'd1 ;

  // rule RL_uart_receive_wait_for_start_bit
  assign CAN_FIRE_RL_uart_receive_wait_for_start_bit =
	     uart_rRecvState == 3'd0 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29 ;
  assign WILL_FIRE_RL_uart_receive_wait_for_start_bit =
	     CAN_FIRE_RL_uart_receive_wait_for_start_bit ;

  // rule RL_uart_receive_find_center_of_bit_cell
  assign CAN_FIRE_RL_uart_receive_find_center_of_bit_cell =
	     uart_rRecvState == 3'd1 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29 ;
  assign WILL_FIRE_RL_uart_receive_find_center_of_bit_cell =
	     CAN_FIRE_RL_uart_receive_find_center_of_bit_cell ;

  // rule RL_uart_receive_wait_bit_cell_time_for_sample
  assign CAN_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample =
	     uart_rRecvState == 3'd2 && uart_rRecvCellCount == 4'hF &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29 ;
  assign WILL_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample =
	     CAN_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample ;

  // rule RL_uart_receive_sample_pin
  assign CAN_FIRE_RL_uart_receive_sample_pin =
	     CAN_FIRE_RL_uart_receive_buffer_shift ;
  assign WILL_FIRE_RL_uart_receive_sample_pin =
	     CAN_FIRE_RL_uart_receive_buffer_shift ;

  // rule RL_uart_receive_parity_bit
  assign CAN_FIRE_RL_uart_receive_parity_bit =
	     uart_rRecvState == 3'd4 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29 ;
  assign WILL_FIRE_RL_uart_receive_parity_bit =
	     CAN_FIRE_RL_uart_receive_parity_bit ;

  // rule RL_uart_receive_stop_first_bit
  assign CAN_FIRE_RL_uart_receive_stop_first_bit =
	     uart_rRecvState == 3'd5 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29 ;
  assign WILL_FIRE_RL_uart_receive_stop_first_bit =
	     CAN_FIRE_RL_uart_receive_stop_first_bit ;

  // rule RL_uart_receive_bit_counter
  assign CAN_FIRE_RL_uart_receive_bit_counter = 1'd1 ;
  assign WILL_FIRE_RL_uart_receive_bit_counter = 1'd1 ;

  // rule RL_uart_receive_stop_last_bit
  assign CAN_FIRE_RL_uart_receive_stop_last_bit =
	     uart_rRecvState == 3'd6 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29 ;
  assign WILL_FIRE_RL_uart_receive_stop_last_bit =
	     CAN_FIRE_RL_uart_receive_stop_last_bit ;

  // rule RL_uart_receive_bit_cell_time_counter
  assign CAN_FIRE_RL_uart_receive_bit_cell_time_counter =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;
  assign WILL_FIRE_RL_uart_receive_bit_cell_time_counter =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;

  // rule RL_uart_receive_buffer_shift
  assign CAN_FIRE_RL_uart_receive_buffer_shift =
	     uart_rRecvState == 3'd3 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29 ;
  assign WILL_FIRE_RL_uart_receive_buffer_shift =
	     CAN_FIRE_RL_uart_receive_buffer_shift ;

  // rule RL_uart_transmit_wait_for_start_command
  assign CAN_FIRE_RL_uart_transmit_wait_for_start_command =
	     uart_rXmitState == 3'd0 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29 ;
  assign WILL_FIRE_RL_uart_transmit_wait_for_start_command =
	     CAN_FIRE_RL_uart_transmit_wait_for_start_command ;

  // rule RL_get_result
  assign CAN_FIRE_RL_get_result =
	     rule30$RDY_getResult && uart_fifoXmit$FULL_N &&
	     transmit_state == 2'd2 ;
  assign WILL_FIRE_RL_get_result = CAN_FIRE_RL_get_result ;

  // rule RL_uart_transmit_send_start_bit
  assign CAN_FIRE_RL_uart_transmit_send_start_bit =
	     uart_rXmitState == 3'd1 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29 ;
  assign WILL_FIRE_RL_uart_transmit_send_start_bit =
	     CAN_FIRE_RL_uart_transmit_send_start_bit ;

  // rule RL_uart_transmit_wait_1_bit_cell_time
  assign CAN_FIRE_RL_uart_transmit_wait_1_bit_cell_time =
	     uart_rXmitState == 3'd2 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29 ;
  assign WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time =
	     CAN_FIRE_RL_uart_transmit_wait_1_bit_cell_time ;

  // rule RL_uart_transmit_bit_counter
  assign CAN_FIRE_RL_uart_transmit_bit_counter = 1'd1 ;
  assign WILL_FIRE_RL_uart_transmit_bit_counter = 1'd1 ;

  // rule RL_uart_transmit_shift_next_bit
  assign CAN_FIRE_RL_uart_transmit_shift_next_bit =
	     uart_rXmitState == 3'd3 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29 ;
  assign WILL_FIRE_RL_uart_transmit_shift_next_bit =
	     CAN_FIRE_RL_uart_transmit_shift_next_bit ;

  // rule RL_uart_transmit_buffer_load
  assign CAN_FIRE_RL_uart_transmit_buffer_load =
	     uart_fifoXmit$EMPTY_N && uart_pwXmitLoadBuffer$whas ;
  assign WILL_FIRE_RL_uart_transmit_buffer_load =
	     CAN_FIRE_RL_uart_transmit_buffer_load ;

  // rule RL_uart_transmit_buffer_shift
  assign CAN_FIRE_RL_uart_transmit_buffer_shift =
	     !uart_pwXmitLoadBuffer$whas &&
	     CAN_FIRE_RL_uart_transmit_shift_next_bit ;
  assign WILL_FIRE_RL_uart_transmit_buffer_shift =
	     CAN_FIRE_RL_uart_transmit_buffer_shift ;

  // rule RL_uart_transmit_send_parity_bit
  assign CAN_FIRE_RL_uart_transmit_send_parity_bit =
	     uart_rXmitState == 3'd7 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29 ;
  assign WILL_FIRE_RL_uart_transmit_send_parity_bit =
	     CAN_FIRE_RL_uart_transmit_send_parity_bit ;

  // rule RL_uart_transmit_send_stop_bit
  assign CAN_FIRE_RL_uart_transmit_send_stop_bit =
	     uart_rXmitState == 3'd4 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29 ;
  assign WILL_FIRE_RL_uart_transmit_send_stop_bit =
	     CAN_FIRE_RL_uart_transmit_send_stop_bit ;

  // rule RL_uart_transmit_send_stop_bit1_5
  assign CAN_FIRE_RL_uart_transmit_send_stop_bit1_5 =
	     uart_rXmitState == 3'd5 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29 ;
  assign WILL_FIRE_RL_uart_transmit_send_stop_bit1_5 =
	     CAN_FIRE_RL_uart_transmit_send_stop_bit1_5 ;

  // rule RL_uart_transmit_send_stop_bit2
  assign CAN_FIRE_RL_uart_transmit_send_stop_bit2 =
	     uart_rXmitState == 3'd6 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29 ;
  assign WILL_FIRE_RL_uart_transmit_send_stop_bit2 =
	     CAN_FIRE_RL_uart_transmit_send_stop_bit2 ;

  // rule RL_uart_transmit_bit_cell_time_counter
  assign CAN_FIRE_RL_uart_transmit_bit_cell_time_counter =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;
  assign WILL_FIRE_RL_uart_transmit_bit_cell_time_counter =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;

  // rule RL_uart_baudGen_baud_tick_count_wire
  assign CAN_FIRE_RL_uart_baudGen_baud_tick_count_wire = 1'd1 ;
  assign WILL_FIRE_RL_uart_baudGen_baud_tick_count_wire = 1'd1 ;

  // rule RL_uart_baudGen_assert_2x_baud_tick
  assign CAN_FIRE_RL_uart_baudGen_assert_2x_baud_tick =
	     uart_baudGen_rBaudTickCounter$Q_OUT == 3'd0 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29 ;
  assign WILL_FIRE_RL_uart_baudGen_assert_2x_baud_tick =
	     CAN_FIRE_RL_uart_baudGen_assert_2x_baud_tick ;

  // rule RL_uart_baudGen_count_baudtick_16x
  assign CAN_FIRE_RL_uart_baudGen_count_baudtick_16x =
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29 ;
  assign WILL_FIRE_RL_uart_baudGen_count_baudtick_16x =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;

  // rule RL_uart_fifoRecv__updateLevelCounter
  assign CAN_FIRE_RL_uart_fifoRecv__updateLevelCounter =
	     CAN_FIRE_RL_uart_receive_stop_last_bit != uart_fifoRecv$EMPTY_N ;
  assign WILL_FIRE_RL_uart_fifoRecv__updateLevelCounter =
	     CAN_FIRE_RL_uart_fifoRecv__updateLevelCounter ;

  // rule RL_uart_fifoXmit__updateLevelCounter
  assign CAN_FIRE_RL_uart_fifoXmit__updateLevelCounter =
	     CAN_FIRE_RL_get_result != CAN_FIRE_RL_uart_transmit_buffer_load ;
  assign WILL_FIRE_RL_uart_fifoXmit__updateLevelCounter =
	     CAN_FIRE_RL_uart_fifoXmit__updateLevelCounter ;

  // inputs to muxes for submodule ports
  assign MUX_transmit_state$write_1__SEL_1 =
	     WILL_FIRE_RL_get_result || EN_startup_value ;
  assign MUX_uart_rRecvState$write_1__SEL_6 =
	     WILL_FIRE_RL_uart_receive_parity_bit ||
	     WILL_FIRE_RL_uart_receive_sample_pin ;
  assign MUX_uart_rXmitDataOut$write_1__SEL_1 =
	     WILL_FIRE_RL_uart_transmit_shift_next_bit ||
	     WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time ;
  assign MUX_uart_rXmitDataOut$write_1__SEL_2 =
	     WILL_FIRE_RL_uart_transmit_send_parity_bit ||
	     WILL_FIRE_RL_uart_transmit_send_start_bit ;
  assign MUX_uart_rXmitDataOut$write_1__SEL_3 =
	     WILL_FIRE_RL_uart_transmit_send_stop_bit2 ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit1_5 ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit ||
	     WILL_FIRE_RL_uart_transmit_wait_for_start_command ;
  assign MUX_uart_rRecvState$write_1__VAL_1 = uart_rRecvData ? 3'd0 : 3'd1 ;
  assign MUX_uart_rRecvState$write_1__VAL_2 =
	     (uart_rRecvCellCount == 4'h4) ?
	       (uart_rRecvData ? 3'd0 : 3'd2) :
	       3'd1 ;
  always@(uart_rRecvBitCount)
  begin
    case (uart_rRecvBitCount)
      4'd8, 4'd9, 4'd10: MUX_uart_rRecvState$write_1__VAL_3 = 3'd6;
      default: MUX_uart_rRecvState$write_1__VAL_3 = 3'd3;
    endcase
  end
  assign MUX_uart_rRecvState$write_1__VAL_4 = uart_rRecvData ? 3'd2 : 3'd0 ;
  assign MUX_uart_rXmitState$write_1__VAL_1 =
	     uart_fifoXmit$EMPTY_N ? 3'd1 : 3'd0 ;
  assign MUX_uart_rXmitState$write_1__VAL_2 =
	     (uart_rXmitCellCount == 4'hF) ? 3'd2 : 3'd1 ;
  assign MUX_uart_rXmitState$write_1__VAL_3 =
	     (uart_rXmitCellCount == 4'hF) ?
	       ((uart_rXmitBitCount == 4'd7) ? 3'd4 : 3'd3) :
	       3'd2 ;
  assign MUX_uart_rXmitState$write_1__VAL_4 =
	     (uart_rXmitCellCount == 4'hF) ? 3'd4 : 3'd7 ;
  assign MUX_uart_rXmitState$write_1__VAL_5 =
	     (uart_rXmitCellCount == 4'hF) ? 3'd0 : 3'd4 ;
  assign MUX_uart_rXmitState$write_1__VAL_6 =
	     (uart_rXmitCellCount == 4'h7) ? 3'd0 : 3'd5 ;
  assign MUX_uart_rXmitState$write_1__VAL_7 =
	     (uart_rXmitCellCount == 4'hF) ? 3'd0 : 3'd6 ;

  // inlined wires
  assign uart_pwRecvCellCountReset$whas =
	     WILL_FIRE_RL_uart_receive_find_center_of_bit_cell &&
	     uart_rRecvCellCount == 4'h4 ||
	     WILL_FIRE_RL_uart_receive_stop_last_bit ||
	     WILL_FIRE_RL_uart_receive_stop_first_bit ||
	     WILL_FIRE_RL_uart_receive_parity_bit ||
	     WILL_FIRE_RL_uart_receive_sample_pin ||
	     WILL_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample ||
	     WILL_FIRE_RL_uart_receive_wait_for_start_bit ;
  assign uart_pwRecvResetBitCount$whas =
	     WILL_FIRE_RL_uart_receive_wait_for_start_bit && uart_rRecvData ;
  assign uart_pwRecvEnableBitCount$whas =
	     WILL_FIRE_RL_uart_receive_stop_first_bit ||
	     WILL_FIRE_RL_uart_receive_parity_bit ||
	     WILL_FIRE_RL_uart_receive_sample_pin ;
  assign uart_pwXmitCellCountReset$whas =
	     WILL_FIRE_RL_uart_transmit_wait_for_start_command &&
	     uart_fifoXmit$EMPTY_N ||
	     _dor2uart_pwXmitCellCountReset$EN_wset &&
	     uart_rXmitCellCount == 4'hF ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit1_5 &&
	     uart_rXmitCellCount == 4'h7 ;
  assign uart_pwXmitEnableBitCount$whas =
	     WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time &&
	     uart_rXmitCellCount == 4'hF &&
	     uart_rXmitBitCount != 4'd7 ;
  assign uart_pwXmitLoadBuffer$whas =
	     WILL_FIRE_RL_uart_transmit_wait_for_start_command &&
	     uart_fifoXmit$EMPTY_N ;

  // register a
  assign a$D_IN = EN_startup_value ? startup_value_v : rule30$getResult ;
  assign a$EN = EN_startup_value || WILL_FIRE_RL_get_result ;

  // register transmit_state
  assign transmit_state$D_IN =
	     MUX_transmit_state$write_1__SEL_1 ? 2'd1 : 2'd2 ;
  assign transmit_state$EN =
	     WILL_FIRE_RL_get_result || EN_startup_value ||
	     WILL_FIRE_RL_compute ;

  // register uart_fifoRecv_countReg
  assign uart_fifoRecv_countReg$D_IN =
	     CAN_FIRE_RL_uart_receive_stop_last_bit ?
	       uart_fifoRecv_countReg + 2'd1 :
	       uart_fifoRecv_countReg - 2'd1 ;
  assign uart_fifoRecv_countReg$EN =
	     CAN_FIRE_RL_uart_fifoRecv__updateLevelCounter ;

  // register uart_fifoXmit_countReg
  assign uart_fifoXmit_countReg$D_IN =
	     CAN_FIRE_RL_get_result ?
	       uart_fifoXmit_countReg + 2'd1 :
	       uart_fifoXmit_countReg - 2'd1 ;
  assign uart_fifoXmit_countReg$EN =
	     CAN_FIRE_RL_uart_fifoXmit__updateLevelCounter ;

  // register uart_rRecvBitCount
  assign uart_rRecvBitCount$D_IN =
	     uart_pwRecvResetBitCount$whas ? 4'd0 : x__h4655 ;
  assign uart_rRecvBitCount$EN =
	     uart_pwRecvResetBitCount$whas || uart_pwRecvEnableBitCount$whas ;

  // register uart_rRecvCellCount
  assign uart_rRecvCellCount$D_IN =
	     uart_pwRecvCellCountReset$whas ? 4'd0 : x__h2951 ;
  assign uart_rRecvCellCount$EN =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;

  // register uart_rRecvData
  assign uart_rRecvData$D_IN = txrx_SIN ;
  assign uart_rRecvData$EN = 1'd1 ;

  // register uart_rRecvParity
  assign uart_rRecvParity$D_IN = uart_rRecvData ;
  assign uart_rRecvParity$EN = CAN_FIRE_RL_uart_receive_parity_bit ;

  // register uart_rRecvState
  always@(WILL_FIRE_RL_uart_receive_wait_for_start_bit or
	  MUX_uart_rRecvState$write_1__VAL_1 or
	  WILL_FIRE_RL_uart_receive_find_center_of_bit_cell or
	  MUX_uart_rRecvState$write_1__VAL_2 or
	  WILL_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample or
	  MUX_uart_rRecvState$write_1__VAL_3 or
	  WILL_FIRE_RL_uart_receive_stop_first_bit or
	  MUX_uart_rRecvState$write_1__VAL_4 or
	  WILL_FIRE_RL_uart_receive_stop_last_bit or
	  MUX_uart_rRecvState$write_1__SEL_6)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_uart_receive_wait_for_start_bit:
	  uart_rRecvState$D_IN = MUX_uart_rRecvState$write_1__VAL_1;
      WILL_FIRE_RL_uart_receive_find_center_of_bit_cell:
	  uart_rRecvState$D_IN = MUX_uart_rRecvState$write_1__VAL_2;
      WILL_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample:
	  uart_rRecvState$D_IN = MUX_uart_rRecvState$write_1__VAL_3;
      WILL_FIRE_RL_uart_receive_stop_first_bit:
	  uart_rRecvState$D_IN = MUX_uart_rRecvState$write_1__VAL_4;
      WILL_FIRE_RL_uart_receive_stop_last_bit: uart_rRecvState$D_IN = 3'd0;
      MUX_uart_rRecvState$write_1__SEL_6: uart_rRecvState$D_IN = 3'd2;
      default: uart_rRecvState$D_IN = 3'b010 /* unspecified value */ ;
    endcase
  end
  assign uart_rRecvState$EN =
	     WILL_FIRE_RL_uart_receive_wait_for_start_bit ||
	     WILL_FIRE_RL_uart_receive_find_center_of_bit_cell ||
	     WILL_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample ||
	     WILL_FIRE_RL_uart_receive_stop_first_bit ||
	     WILL_FIRE_RL_uart_receive_stop_last_bit ||
	     WILL_FIRE_RL_uart_receive_parity_bit ||
	     WILL_FIRE_RL_uart_receive_sample_pin ;

  // register uart_rXmitBitCount
  assign uart_rXmitBitCount$D_IN =
	     CAN_FIRE_RL_uart_transmit_wait_for_start_command ?
	       4'd0 :
	       x__h6437 ;
  assign uart_rXmitBitCount$EN =
	     CAN_FIRE_RL_uart_transmit_wait_for_start_command ||
	     uart_pwXmitEnableBitCount$whas ;

  // register uart_rXmitCellCount
  assign uart_rXmitCellCount$D_IN =
	     uart_pwXmitCellCountReset$whas ? 4'd0 : x__h6411 ;
  assign uart_rXmitCellCount$EN =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;

  // register uart_rXmitDataOut
  always@(MUX_uart_rXmitDataOut$write_1__SEL_1 or
	  uart_vrXmitBuffer_0 or
	  MUX_uart_rXmitDataOut$write_1__SEL_2 or
	  MUX_uart_rXmitDataOut$write_1__SEL_3)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_uart_rXmitDataOut$write_1__SEL_1:
	  uart_rXmitDataOut$D_IN = uart_vrXmitBuffer_0;
      MUX_uart_rXmitDataOut$write_1__SEL_2: uart_rXmitDataOut$D_IN = 1'b0;
      MUX_uart_rXmitDataOut$write_1__SEL_3: uart_rXmitDataOut$D_IN = 1'b1;
      default: uart_rXmitDataOut$D_IN = 1'b0 /* unspecified value */ ;
    endcase
  end
  assign uart_rXmitDataOut$EN =
	     WILL_FIRE_RL_uart_transmit_shift_next_bit ||
	     WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time ||
	     WILL_FIRE_RL_uart_transmit_send_parity_bit ||
	     WILL_FIRE_RL_uart_transmit_send_start_bit ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit2 ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit1_5 ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit ||
	     WILL_FIRE_RL_uart_transmit_wait_for_start_command ;

  // register uart_rXmitParity
  assign uart_rXmitParity$D_IN = z__h7929 ^ uart_fifoXmit$D_OUT[7] ;
  assign uart_rXmitParity$EN = CAN_FIRE_RL_uart_transmit_buffer_load ;

  // register uart_rXmitState
  always@(WILL_FIRE_RL_uart_transmit_wait_for_start_command or
	  MUX_uart_rXmitState$write_1__VAL_1 or
	  WILL_FIRE_RL_uart_transmit_send_start_bit or
	  MUX_uart_rXmitState$write_1__VAL_2 or
	  WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time or
	  MUX_uart_rXmitState$write_1__VAL_3 or
	  WILL_FIRE_RL_uart_transmit_send_parity_bit or
	  MUX_uart_rXmitState$write_1__VAL_4 or
	  WILL_FIRE_RL_uart_transmit_send_stop_bit or
	  MUX_uart_rXmitState$write_1__VAL_5 or
	  WILL_FIRE_RL_uart_transmit_send_stop_bit1_5 or
	  MUX_uart_rXmitState$write_1__VAL_6 or
	  WILL_FIRE_RL_uart_transmit_send_stop_bit2 or
	  MUX_uart_rXmitState$write_1__VAL_7 or
	  WILL_FIRE_RL_uart_transmit_shift_next_bit)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_uart_transmit_wait_for_start_command:
	  uart_rXmitState$D_IN = MUX_uart_rXmitState$write_1__VAL_1;
      WILL_FIRE_RL_uart_transmit_send_start_bit:
	  uart_rXmitState$D_IN = MUX_uart_rXmitState$write_1__VAL_2;
      WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time:
	  uart_rXmitState$D_IN = MUX_uart_rXmitState$write_1__VAL_3;
      WILL_FIRE_RL_uart_transmit_send_parity_bit:
	  uart_rXmitState$D_IN = MUX_uart_rXmitState$write_1__VAL_4;
      WILL_FIRE_RL_uart_transmit_send_stop_bit:
	  uart_rXmitState$D_IN = MUX_uart_rXmitState$write_1__VAL_5;
      WILL_FIRE_RL_uart_transmit_send_stop_bit1_5:
	  uart_rXmitState$D_IN = MUX_uart_rXmitState$write_1__VAL_6;
      WILL_FIRE_RL_uart_transmit_send_stop_bit2:
	  uart_rXmitState$D_IN = MUX_uart_rXmitState$write_1__VAL_7;
      WILL_FIRE_RL_uart_transmit_shift_next_bit: uart_rXmitState$D_IN = 3'd2;
      default: uart_rXmitState$D_IN = 3'b010 /* unspecified value */ ;
    endcase
  end
  assign uart_rXmitState$EN =
	     WILL_FIRE_RL_uart_transmit_wait_for_start_command ||
	     WILL_FIRE_RL_uart_transmit_send_start_bit ||
	     WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time ||
	     WILL_FIRE_RL_uart_transmit_send_parity_bit ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit1_5 ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit2 ||
	     WILL_FIRE_RL_uart_transmit_shift_next_bit ;

  // register uart_vrRecvBuffer_0
  assign uart_vrRecvBuffer_0$D_IN = uart_vrRecvBuffer_1 ;
  assign uart_vrRecvBuffer_0$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrRecvBuffer_1
  assign uart_vrRecvBuffer_1$D_IN = uart_vrRecvBuffer_2 ;
  assign uart_vrRecvBuffer_1$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrRecvBuffer_2
  assign uart_vrRecvBuffer_2$D_IN = uart_vrRecvBuffer_3 ;
  assign uart_vrRecvBuffer_2$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrRecvBuffer_3
  assign uart_vrRecvBuffer_3$D_IN = uart_vrRecvBuffer_4 ;
  assign uart_vrRecvBuffer_3$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrRecvBuffer_4
  assign uart_vrRecvBuffer_4$D_IN = uart_vrRecvBuffer_5 ;
  assign uart_vrRecvBuffer_4$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrRecvBuffer_5
  assign uart_vrRecvBuffer_5$D_IN = uart_vrRecvBuffer_6 ;
  assign uart_vrRecvBuffer_5$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrRecvBuffer_6
  assign uart_vrRecvBuffer_6$D_IN = uart_vrRecvBuffer_7 ;
  assign uart_vrRecvBuffer_6$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrRecvBuffer_7
  assign uart_vrRecvBuffer_7$D_IN = uart_rRecvData ;
  assign uart_vrRecvBuffer_7$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrXmitBuffer_0
  assign uart_vrXmitBuffer_0$D_IN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ?
	       uart_fifoXmit$D_OUT[0] :
	       uart_vrXmitBuffer_1 ;
  assign uart_vrXmitBuffer_0$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // register uart_vrXmitBuffer_1
  assign uart_vrXmitBuffer_1$D_IN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ?
	       uart_fifoXmit$D_OUT[1] :
	       uart_vrXmitBuffer_2 ;
  assign uart_vrXmitBuffer_1$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // register uart_vrXmitBuffer_2
  assign uart_vrXmitBuffer_2$D_IN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ?
	       uart_fifoXmit$D_OUT[2] :
	       uart_vrXmitBuffer_3 ;
  assign uart_vrXmitBuffer_2$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // register uart_vrXmitBuffer_3
  assign uart_vrXmitBuffer_3$D_IN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ?
	       uart_fifoXmit$D_OUT[3] :
	       uart_vrXmitBuffer_4 ;
  assign uart_vrXmitBuffer_3$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // register uart_vrXmitBuffer_4
  assign uart_vrXmitBuffer_4$D_IN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ?
	       uart_fifoXmit$D_OUT[4] :
	       uart_vrXmitBuffer_5 ;
  assign uart_vrXmitBuffer_4$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // register uart_vrXmitBuffer_5
  assign uart_vrXmitBuffer_5$D_IN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ?
	       uart_fifoXmit$D_OUT[5] :
	       uart_vrXmitBuffer_6 ;
  assign uart_vrXmitBuffer_5$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // register uart_vrXmitBuffer_6
  assign uart_vrXmitBuffer_6$D_IN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ?
	       uart_fifoXmit$D_OUT[6] :
	       uart_vrXmitBuffer_7 ;
  assign uart_vrXmitBuffer_6$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // register uart_vrXmitBuffer_7
  assign uart_vrXmitBuffer_7$D_IN =
	     !WILL_FIRE_RL_uart_transmit_buffer_load ||
	     uart_fifoXmit$D_OUT[7] ;
  assign uart_vrXmitBuffer_7$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // submodule rule30
  assign rule30$start_a = a ;
  assign rule30$EN_start = CAN_FIRE_RL_compute ;
  assign rule30$EN_getResult = CAN_FIRE_RL_get_result ;

  // submodule uart_baudGen_rBaudCounter
  assign uart_baudGen_rBaudCounter$DATA_A = 16'd1 ;
  assign uart_baudGen_rBaudCounter$DATA_B = 16'h0 ;
  assign uart_baudGen_rBaudCounter$DATA_C = 16'h0 ;
  assign uart_baudGen_rBaudCounter$DATA_F = 16'd0 ;
  assign uart_baudGen_rBaudCounter$ADDA =
	     uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29 ;
  assign uart_baudGen_rBaudCounter$ADDB = 1'b0 ;
  assign uart_baudGen_rBaudCounter$SETC = 1'b0 ;
  assign uart_baudGen_rBaudCounter$SETF =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;

  // submodule uart_baudGen_rBaudTickCounter
  assign uart_baudGen_rBaudTickCounter$DATA_A = 3'd1 ;
  assign uart_baudGen_rBaudTickCounter$DATA_B = 3'h0 ;
  assign uart_baudGen_rBaudTickCounter$DATA_C = 3'h0 ;
  assign uart_baudGen_rBaudTickCounter$DATA_F = 3'h0 ;
  assign uart_baudGen_rBaudTickCounter$ADDA =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;
  assign uart_baudGen_rBaudTickCounter$ADDB = 1'b0 ;
  assign uart_baudGen_rBaudTickCounter$SETC = 1'b0 ;
  assign uart_baudGen_rBaudTickCounter$SETF = 1'b0 ;

  // submodule uart_fifoRecv
  assign uart_fifoRecv$D_IN =
	     { uart_vrRecvBuffer_7,
	       uart_vrRecvBuffer_6,
	       uart_vrRecvBuffer_5,
	       uart_vrRecvBuffer_4,
	       uart_vrRecvBuffer_3,
	       uart_vrRecvBuffer_2,
	       uart_vrRecvBuffer_1,
	       uart_vrRecvBuffer_0 } ;
  assign uart_fifoRecv$ENQ = CAN_FIRE_RL_uart_receive_stop_last_bit ;
  assign uart_fifoRecv$DEQ = uart_fifoRecv$EMPTY_N ;
  assign uart_fifoRecv$CLR = 1'b0 ;

  // submodule uart_fifoXmit
  assign uart_fifoXmit$D_IN = rule30$getResult ;
  assign uart_fifoXmit$ENQ = CAN_FIRE_RL_get_result ;
  assign uart_fifoXmit$DEQ = CAN_FIRE_RL_uart_transmit_buffer_load ;
  assign uart_fifoXmit$CLR = 1'b0 ;

  // remaining internal signals
  assign _dor2uart_pwXmitCellCountReset$EN_wset =
	     WILL_FIRE_RL_uart_transmit_send_stop_bit2 ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit ||
	     WILL_FIRE_RL_uart_transmit_send_parity_bit ||
	     WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time ||
	     WILL_FIRE_RL_uart_transmit_send_start_bit ;
  assign uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29 =
	     uart_baudGen_rBaudCounter$Q_OUT + 16'd1 < 16'd27 ;
  assign x__h2951 = uart_rRecvCellCount + 4'd1 ;
  assign x__h4655 = uart_rRecvBitCount + 4'd1 ;
  assign x__h6411 = uart_rXmitCellCount + 4'd1 ;
  assign x__h6437 = uart_rXmitBitCount + 4'd1 ;
  assign z__h7894 = uart_fifoXmit$D_OUT[0] ^ uart_fifoXmit$D_OUT[1] ;
  assign z__h7901 = z__h7894 ^ uart_fifoXmit$D_OUT[2] ;
  assign z__h7908 = z__h7901 ^ uart_fifoXmit$D_OUT[3] ;
  assign z__h7915 = z__h7908 ^ uart_fifoXmit$D_OUT[4] ;
  assign z__h7922 = z__h7915 ^ uart_fifoXmit$D_OUT[5] ;
  assign z__h7929 = z__h7922 ^ uart_fifoXmit$D_OUT[6] ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        a <= `BSV_ASSIGNMENT_DELAY 8'b0;
	transmit_state <= `BSV_ASSIGNMENT_DELAY 2'd0;
	uart_fifoRecv_countReg <= `BSV_ASSIGNMENT_DELAY 2'd0;
	uart_fifoXmit_countReg <= `BSV_ASSIGNMENT_DELAY 2'd0;
	uart_rRecvData <= `BSV_ASSIGNMENT_DELAY 1'd1;
      end
    else
      begin
        if (a$EN) a <= `BSV_ASSIGNMENT_DELAY a$D_IN;
	if (transmit_state$EN)
	  transmit_state <= `BSV_ASSIGNMENT_DELAY transmit_state$D_IN;
	if (uart_fifoRecv_countReg$EN)
	  uart_fifoRecv_countReg <= `BSV_ASSIGNMENT_DELAY
	      uart_fifoRecv_countReg$D_IN;
	if (uart_fifoXmit_countReg$EN)
	  uart_fifoXmit_countReg <= `BSV_ASSIGNMENT_DELAY
	      uart_fifoXmit_countReg$D_IN;
	if (uart_rRecvData$EN)
	  uart_rRecvData <= `BSV_ASSIGNMENT_DELAY uart_rRecvData$D_IN;
      end
    if (uart_vrRecvBuffer_0$EN)
      uart_vrRecvBuffer_0 <= `BSV_ASSIGNMENT_DELAY uart_vrRecvBuffer_0$D_IN;
    if (uart_vrRecvBuffer_1$EN)
      uart_vrRecvBuffer_1 <= `BSV_ASSIGNMENT_DELAY uart_vrRecvBuffer_1$D_IN;
    if (uart_vrRecvBuffer_2$EN)
      uart_vrRecvBuffer_2 <= `BSV_ASSIGNMENT_DELAY uart_vrRecvBuffer_2$D_IN;
    if (uart_vrRecvBuffer_3$EN)
      uart_vrRecvBuffer_3 <= `BSV_ASSIGNMENT_DELAY uart_vrRecvBuffer_3$D_IN;
    if (uart_vrRecvBuffer_4$EN)
      uart_vrRecvBuffer_4 <= `BSV_ASSIGNMENT_DELAY uart_vrRecvBuffer_4$D_IN;
    if (uart_vrRecvBuffer_5$EN)
      uart_vrRecvBuffer_5 <= `BSV_ASSIGNMENT_DELAY uart_vrRecvBuffer_5$D_IN;
    if (uart_vrRecvBuffer_6$EN)
      uart_vrRecvBuffer_6 <= `BSV_ASSIGNMENT_DELAY uart_vrRecvBuffer_6$D_IN;
    if (uart_vrRecvBuffer_7$EN)
      uart_vrRecvBuffer_7 <= `BSV_ASSIGNMENT_DELAY uart_vrRecvBuffer_7$D_IN;
    if (uart_vrXmitBuffer_0$EN)
      uart_vrXmitBuffer_0 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_0$D_IN;
    if (uart_vrXmitBuffer_1$EN)
      uart_vrXmitBuffer_1 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_1$D_IN;
    if (uart_vrXmitBuffer_2$EN)
      uart_vrXmitBuffer_2 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_2$D_IN;
    if (uart_vrXmitBuffer_3$EN)
      uart_vrXmitBuffer_3 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_3$D_IN;
    if (uart_vrXmitBuffer_4$EN)
      uart_vrXmitBuffer_4 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_4$D_IN;
    if (uart_vrXmitBuffer_5$EN)
      uart_vrXmitBuffer_5 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_5$D_IN;
    if (uart_vrXmitBuffer_6$EN)
      uart_vrXmitBuffer_6 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_6$D_IN;
    if (uart_vrXmitBuffer_7$EN)
      uart_vrXmitBuffer_7 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_7$D_IN;
  end

  always@(posedge CLK or `BSV_RESET_EDGE RST_N)
  if (RST_N == `BSV_RESET_VALUE)
    begin
      uart_rRecvBitCount <= `BSV_ASSIGNMENT_DELAY 4'd0;
      uart_rRecvCellCount <= `BSV_ASSIGNMENT_DELAY 4'd0;
      uart_rRecvParity <= `BSV_ASSIGNMENT_DELAY 1'd0;
      uart_rRecvState <= `BSV_ASSIGNMENT_DELAY 3'd0;
      uart_rXmitBitCount <= `BSV_ASSIGNMENT_DELAY 4'd0;
      uart_rXmitCellCount <= `BSV_ASSIGNMENT_DELAY 4'd0;
      uart_rXmitDataOut <= `BSV_ASSIGNMENT_DELAY 1'd1;
      uart_rXmitParity <= `BSV_ASSIGNMENT_DELAY 1'd0;
      uart_rXmitState <= `BSV_ASSIGNMENT_DELAY 3'd0;
    end
  else
    begin
      if (uart_rRecvBitCount$EN)
	uart_rRecvBitCount <= `BSV_ASSIGNMENT_DELAY uart_rRecvBitCount$D_IN;
      if (uart_rRecvCellCount$EN)
	uart_rRecvCellCount <= `BSV_ASSIGNMENT_DELAY uart_rRecvCellCount$D_IN;
      if (uart_rRecvParity$EN)
	uart_rRecvParity <= `BSV_ASSIGNMENT_DELAY uart_rRecvParity$D_IN;
      if (uart_rRecvState$EN)
	uart_rRecvState <= `BSV_ASSIGNMENT_DELAY uart_rRecvState$D_IN;
      if (uart_rXmitBitCount$EN)
	uart_rXmitBitCount <= `BSV_ASSIGNMENT_DELAY uart_rXmitBitCount$D_IN;
      if (uart_rXmitCellCount$EN)
	uart_rXmitCellCount <= `BSV_ASSIGNMENT_DELAY uart_rXmitCellCount$D_IN;
      if (uart_rXmitDataOut$EN)
	uart_rXmitDataOut <= `BSV_ASSIGNMENT_DELAY uart_rXmitDataOut$D_IN;
      if (uart_rXmitParity$EN)
	uart_rXmitParity <= `BSV_ASSIGNMENT_DELAY uart_rXmitParity$D_IN;
      if (uart_rXmitState$EN)
	uart_rXmitState <= `BSV_ASSIGNMENT_DELAY uart_rXmitState$D_IN;
    end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    a = 8'hAA;
    transmit_state = 2'h2;
    uart_fifoRecv_countReg = 2'h2;
    uart_fifoXmit_countReg = 2'h2;
    uart_rRecvBitCount = 4'hA;
    uart_rRecvCellCount = 4'hA;
    uart_rRecvData = 1'h0;
    uart_rRecvParity = 1'h0;
    uart_rRecvState = 3'h2;
    uart_rXmitBitCount = 4'hA;
    uart_rXmitCellCount = 4'hA;
    uart_rXmitDataOut = 1'h0;
    uart_rXmitParity = 1'h0;
    uart_rXmitState = 3'h2;
    uart_vrRecvBuffer_0 = 1'h0;
    uart_vrRecvBuffer_1 = 1'h0;
    uart_vrRecvBuffer_2 = 1'h0;
    uart_vrRecvBuffer_3 = 1'h0;
    uart_vrRecvBuffer_4 = 1'h0;
    uart_vrRecvBuffer_5 = 1'h0;
    uart_vrRecvBuffer_6 = 1'h0;
    uart_vrRecvBuffer_7 = 1'h0;
    uart_vrXmitBuffer_0 = 1'h0;
    uart_vrXmitBuffer_1 = 1'h0;
    uart_vrXmitBuffer_2 = 1'h0;
    uart_vrXmitBuffer_3 = 1'h0;
    uart_vrXmitBuffer_4 = 1'h0;
    uart_vrXmitBuffer_5 = 1'h0;
    uart_vrXmitBuffer_6 = 1'h0;
    uart_vrXmitBuffer_7 = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkRule30Driver

