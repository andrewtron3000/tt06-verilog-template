//
// Generated by Bluespec Compiler, version 2024.01-1-g4d953407 (build 4d953407)
//
// On Thu Apr 18 23:03:53 EDT 2024
//
//
// Ports:
// Name                         I/O  size props
// RDY_operation_mode             O     1
// RDY_startup_value              O     1
// txrx_SOUT                      O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// operation_mode_arg             I     8
// startup_value_v                I     8
// txrx_SIN                       I     1 reg
// EN_operation_mode              I     1
// EN_startup_value               I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkRule30Driver(CLK,
		      RST_N,

		      operation_mode_arg,
		      EN_operation_mode,
		      RDY_operation_mode,

		      startup_value_v,
		      EN_startup_value,
		      RDY_startup_value,

		      txrx_SIN,

		      txrx_SOUT);
  input  CLK;
  input  RST_N;

  // action method operation_mode
  input  [7 : 0] operation_mode_arg;
  input  EN_operation_mode;
  output RDY_operation_mode;

  // action method startup_value
  input  [7 : 0] startup_value_v;
  input  EN_startup_value;
  output RDY_startup_value;

  // action method txrx_sin
  input  txrx_SIN;

  // value method txrx_sout
  output txrx_SOUT;

  // signals for module outputs
  wire RDY_operation_mode, RDY_startup_value, txrx_SOUT;

  // inlined wires
  wire uart_fifoXmit_r_enq$whas,
       uart_pwRecvCellCountReset$whas,
       uart_pwRecvEnableBitCount$whas,
       uart_pwRecvResetBitCount$whas,
       uart_pwXmitCellCountReset$whas,
       uart_pwXmitEnableBitCount$whas,
       uart_pwXmitLoadBuffer$whas,
       xmas_fsm_start_wire$whas,
       xmas_fsm_state_set_pw$whas;

  // register a
  reg [7 : 0] a;
  wire [7 : 0] a$D_IN;
  wire a$EN;

  // register op_mode
  reg op_mode;
  wire op_mode$D_IN, op_mode$EN;

  // register transmit_state
  reg [1 : 0] transmit_state;
  wire [1 : 0] transmit_state$D_IN;
  wire transmit_state$EN;

  // register uart_rRecvBitCount
  reg [3 : 0] uart_rRecvBitCount;
  wire [3 : 0] uart_rRecvBitCount$D_IN;
  wire uart_rRecvBitCount$EN;

  // register uart_rRecvCellCount
  reg [3 : 0] uart_rRecvCellCount;
  wire [3 : 0] uart_rRecvCellCount$D_IN;
  wire uart_rRecvCellCount$EN;

  // register uart_rRecvData
  reg uart_rRecvData;
  wire uart_rRecvData$D_IN, uart_rRecvData$EN;

  // register uart_rRecvState
  reg [2 : 0] uart_rRecvState;
  reg [2 : 0] uart_rRecvState$D_IN;
  wire uart_rRecvState$EN;

  // register uart_rXmitBitCount
  reg [3 : 0] uart_rXmitBitCount;
  wire [3 : 0] uart_rXmitBitCount$D_IN;
  wire uart_rXmitBitCount$EN;

  // register uart_rXmitCellCount
  reg [3 : 0] uart_rXmitCellCount;
  wire [3 : 0] uart_rXmitCellCount$D_IN;
  wire uart_rXmitCellCount$EN;

  // register uart_rXmitDataOut
  reg uart_rXmitDataOut;
  reg uart_rXmitDataOut$D_IN;
  wire uart_rXmitDataOut$EN;

  // register uart_rXmitState
  reg [2 : 0] uart_rXmitState;
  reg [2 : 0] uart_rXmitState$D_IN;
  wire uart_rXmitState$EN;

  // register uart_vrRecvBuffer_0
  reg uart_vrRecvBuffer_0;
  wire uart_vrRecvBuffer_0$D_IN, uart_vrRecvBuffer_0$EN;

  // register uart_vrRecvBuffer_1
  reg uart_vrRecvBuffer_1;
  wire uart_vrRecvBuffer_1$D_IN, uart_vrRecvBuffer_1$EN;

  // register uart_vrRecvBuffer_2
  reg uart_vrRecvBuffer_2;
  wire uart_vrRecvBuffer_2$D_IN, uart_vrRecvBuffer_2$EN;

  // register uart_vrRecvBuffer_3
  reg uart_vrRecvBuffer_3;
  wire uart_vrRecvBuffer_3$D_IN, uart_vrRecvBuffer_3$EN;

  // register uart_vrRecvBuffer_4
  reg uart_vrRecvBuffer_4;
  wire uart_vrRecvBuffer_4$D_IN, uart_vrRecvBuffer_4$EN;

  // register uart_vrRecvBuffer_5
  reg uart_vrRecvBuffer_5;
  wire uart_vrRecvBuffer_5$D_IN, uart_vrRecvBuffer_5$EN;

  // register uart_vrRecvBuffer_6
  reg uart_vrRecvBuffer_6;
  wire uart_vrRecvBuffer_6$D_IN, uart_vrRecvBuffer_6$EN;

  // register uart_vrRecvBuffer_7
  reg uart_vrRecvBuffer_7;
  wire uart_vrRecvBuffer_7$D_IN, uart_vrRecvBuffer_7$EN;

  // register uart_vrXmitBuffer_0
  reg uart_vrXmitBuffer_0;
  wire uart_vrXmitBuffer_0$D_IN, uart_vrXmitBuffer_0$EN;

  // register uart_vrXmitBuffer_1
  reg uart_vrXmitBuffer_1;
  wire uart_vrXmitBuffer_1$D_IN, uart_vrXmitBuffer_1$EN;

  // register uart_vrXmitBuffer_2
  reg uart_vrXmitBuffer_2;
  wire uart_vrXmitBuffer_2$D_IN, uart_vrXmitBuffer_2$EN;

  // register uart_vrXmitBuffer_3
  reg uart_vrXmitBuffer_3;
  wire uart_vrXmitBuffer_3$D_IN, uart_vrXmitBuffer_3$EN;

  // register uart_vrXmitBuffer_4
  reg uart_vrXmitBuffer_4;
  wire uart_vrXmitBuffer_4$D_IN, uart_vrXmitBuffer_4$EN;

  // register uart_vrXmitBuffer_5
  reg uart_vrXmitBuffer_5;
  wire uart_vrXmitBuffer_5$D_IN, uart_vrXmitBuffer_5$EN;

  // register uart_vrXmitBuffer_6
  reg uart_vrXmitBuffer_6;
  wire uart_vrXmitBuffer_6$D_IN, uart_vrXmitBuffer_6$EN;

  // register uart_vrXmitBuffer_7
  reg uart_vrXmitBuffer_7;
  wire uart_vrXmitBuffer_7$D_IN, uart_vrXmitBuffer_7$EN;

  // register xmas_fsm_start_reg
  reg xmas_fsm_start_reg;
  wire xmas_fsm_start_reg$D_IN, xmas_fsm_start_reg$EN;

  // register xmas_fsm_start_reg_1
  reg xmas_fsm_start_reg_1;
  wire xmas_fsm_start_reg_1$D_IN, xmas_fsm_start_reg_1$EN;

  // register xmas_fsm_state_fired
  reg xmas_fsm_state_fired;
  wire xmas_fsm_state_fired$D_IN, xmas_fsm_state_fired$EN;

  // register xmas_fsm_state_mkFSMstate
  reg [4 : 0] xmas_fsm_state_mkFSMstate;
  reg [4 : 0] xmas_fsm_state_mkFSMstate$D_IN;
  wire xmas_fsm_state_mkFSMstate$EN;

  // ports of submodule rule30
  wire [7 : 0] rule30$getResult, rule30$start_a;
  wire rule30$EN_getResult,
       rule30$EN_start,
       rule30$RDY_getResult,
       rule30$RDY_start;

  // ports of submodule uart_baudGen_rBaudCounter
  wire [15 : 0] uart_baudGen_rBaudCounter$DATA_A,
		uart_baudGen_rBaudCounter$DATA_B,
		uart_baudGen_rBaudCounter$DATA_C,
		uart_baudGen_rBaudCounter$DATA_F,
		uart_baudGen_rBaudCounter$Q_OUT;
  wire uart_baudGen_rBaudCounter$ADDA,
       uart_baudGen_rBaudCounter$ADDB,
       uart_baudGen_rBaudCounter$SETC,
       uart_baudGen_rBaudCounter$SETF;

  // ports of submodule uart_baudGen_rBaudTickCounter
  wire [2 : 0] uart_baudGen_rBaudTickCounter$DATA_A,
	       uart_baudGen_rBaudTickCounter$DATA_B,
	       uart_baudGen_rBaudTickCounter$DATA_C,
	       uart_baudGen_rBaudTickCounter$DATA_F,
	       uart_baudGen_rBaudTickCounter$Q_OUT;
  wire uart_baudGen_rBaudTickCounter$ADDA,
       uart_baudGen_rBaudTickCounter$ADDB,
       uart_baudGen_rBaudTickCounter$SETC,
       uart_baudGen_rBaudTickCounter$SETF;

  // ports of submodule uart_fifoRecv
  wire [7 : 0] uart_fifoRecv$D_IN;
  wire uart_fifoRecv$CLR,
       uart_fifoRecv$DEQ,
       uart_fifoRecv$EMPTY_N,
       uart_fifoRecv$ENQ;

  // ports of submodule uart_fifoXmit
  reg [7 : 0] uart_fifoXmit$D_IN;
  wire [7 : 0] uart_fifoXmit$D_OUT;
  wire uart_fifoXmit$CLR,
       uart_fifoXmit$DEQ,
       uart_fifoXmit$EMPTY_N,
       uart_fifoXmit$ENQ,
       uart_fifoXmit$FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_compute,
       CAN_FIRE_RL_dump_rx,
       CAN_FIRE_RL_get_result,
       CAN_FIRE_RL_uart_baudGen_assert_2x_baud_tick,
       CAN_FIRE_RL_uart_baudGen_baud_count_wire,
       CAN_FIRE_RL_uart_baudGen_baud_tick_count_wire,
       CAN_FIRE_RL_uart_baudGen_count_baudtick_16x,
       CAN_FIRE_RL_uart_baud_generator_clock_enable,
       CAN_FIRE_RL_uart_fifoRecv__updateLevelCounter,
       CAN_FIRE_RL_uart_fifoXmit__updateLevelCounter,
       CAN_FIRE_RL_uart_receive_bit_cell_time_counter,
       CAN_FIRE_RL_uart_receive_bit_counter,
       CAN_FIRE_RL_uart_receive_buffer_shift,
       CAN_FIRE_RL_uart_receive_find_center_of_bit_cell,
       CAN_FIRE_RL_uart_receive_parity_bit,
       CAN_FIRE_RL_uart_receive_sample_pin,
       CAN_FIRE_RL_uart_receive_stop_first_bit,
       CAN_FIRE_RL_uart_receive_stop_last_bit,
       CAN_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample,
       CAN_FIRE_RL_uart_receive_wait_for_start_bit,
       CAN_FIRE_RL_uart_transmit_bit_cell_time_counter,
       CAN_FIRE_RL_uart_transmit_bit_counter,
       CAN_FIRE_RL_uart_transmit_buffer_load,
       CAN_FIRE_RL_uart_transmit_buffer_shift,
       CAN_FIRE_RL_uart_transmit_send_parity_bit,
       CAN_FIRE_RL_uart_transmit_send_start_bit,
       CAN_FIRE_RL_uart_transmit_send_stop_bit,
       CAN_FIRE_RL_uart_transmit_send_stop_bit1_5,
       CAN_FIRE_RL_uart_transmit_send_stop_bit2,
       CAN_FIRE_RL_uart_transmit_shift_next_bit,
       CAN_FIRE_RL_uart_transmit_wait_1_bit_cell_time,
       CAN_FIRE_RL_uart_transmit_wait_for_start_command,
       CAN_FIRE_RL_xmas_fsm_action_l42c32,
       CAN_FIRE_RL_xmas_fsm_action_l43c32,
       CAN_FIRE_RL_xmas_fsm_action_l44c32,
       CAN_FIRE_RL_xmas_fsm_action_l45c32,
       CAN_FIRE_RL_xmas_fsm_action_l46c32,
       CAN_FIRE_RL_xmas_fsm_action_l47c32,
       CAN_FIRE_RL_xmas_fsm_action_l48c32,
       CAN_FIRE_RL_xmas_fsm_action_l49c32,
       CAN_FIRE_RL_xmas_fsm_action_l50c32,
       CAN_FIRE_RL_xmas_fsm_action_l51c32,
       CAN_FIRE_RL_xmas_fsm_action_l52c32,
       CAN_FIRE_RL_xmas_fsm_action_l53c32,
       CAN_FIRE_RL_xmas_fsm_action_l54c32,
       CAN_FIRE_RL_xmas_fsm_action_l55c32,
       CAN_FIRE_RL_xmas_fsm_action_l56c32,
       CAN_FIRE_RL_xmas_fsm_action_l57c32,
       CAN_FIRE_RL_xmas_fsm_action_l58c32,
       CAN_FIRE_RL_xmas_fsm_action_l59c32,
       CAN_FIRE_RL_xmas_fsm_action_l60c32,
       CAN_FIRE_RL_xmas_fsm_action_l61c32,
       CAN_FIRE_RL_xmas_fsm_action_l62c32,
       CAN_FIRE_RL_xmas_fsm_action_l63c32,
       CAN_FIRE_RL_xmas_fsm_action_l64c32,
       CAN_FIRE_RL_xmas_fsm_action_l65c32,
       CAN_FIRE_RL_xmas_fsm_action_l66c32,
       CAN_FIRE_RL_xmas_fsm_fsm_start,
       CAN_FIRE_RL_xmas_fsm_idle_l40c27,
       CAN_FIRE_RL_xmas_fsm_idle_l40c27_1,
       CAN_FIRE_RL_xmas_fsm_restart,
       CAN_FIRE_RL_xmas_fsm_start_reg__dreg_update,
       CAN_FIRE_RL_xmas_fsm_state_every,
       CAN_FIRE_RL_xmas_fsm_state_fired__dreg_update,
       CAN_FIRE_RL_xmas_fsm_state_handle_abort,
       CAN_FIRE___me_check_34,
       CAN_FIRE___me_check_35,
       CAN_FIRE___me_check_36,
       CAN_FIRE___me_check_37,
       CAN_FIRE___me_check_38,
       CAN_FIRE___me_check_39,
       CAN_FIRE___me_check_40,
       CAN_FIRE___me_check_41,
       CAN_FIRE___me_check_42,
       CAN_FIRE___me_check_43,
       CAN_FIRE___me_check_44,
       CAN_FIRE___me_check_45,
       CAN_FIRE___me_check_46,
       CAN_FIRE___me_check_47,
       CAN_FIRE___me_check_48,
       CAN_FIRE___me_check_49,
       CAN_FIRE___me_check_50,
       CAN_FIRE___me_check_51,
       CAN_FIRE___me_check_52,
       CAN_FIRE___me_check_53,
       CAN_FIRE___me_check_54,
       CAN_FIRE___me_check_55,
       CAN_FIRE___me_check_56,
       CAN_FIRE___me_check_57,
       CAN_FIRE_operation_mode,
       CAN_FIRE_startup_value,
       CAN_FIRE_txrx_sin,
       WILL_FIRE_RL_compute,
       WILL_FIRE_RL_dump_rx,
       WILL_FIRE_RL_get_result,
       WILL_FIRE_RL_uart_baudGen_assert_2x_baud_tick,
       WILL_FIRE_RL_uart_baudGen_baud_count_wire,
       WILL_FIRE_RL_uart_baudGen_baud_tick_count_wire,
       WILL_FIRE_RL_uart_baudGen_count_baudtick_16x,
       WILL_FIRE_RL_uart_baud_generator_clock_enable,
       WILL_FIRE_RL_uart_fifoRecv__updateLevelCounter,
       WILL_FIRE_RL_uart_fifoXmit__updateLevelCounter,
       WILL_FIRE_RL_uart_receive_bit_cell_time_counter,
       WILL_FIRE_RL_uart_receive_bit_counter,
       WILL_FIRE_RL_uart_receive_buffer_shift,
       WILL_FIRE_RL_uart_receive_find_center_of_bit_cell,
       WILL_FIRE_RL_uart_receive_parity_bit,
       WILL_FIRE_RL_uart_receive_sample_pin,
       WILL_FIRE_RL_uart_receive_stop_first_bit,
       WILL_FIRE_RL_uart_receive_stop_last_bit,
       WILL_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample,
       WILL_FIRE_RL_uart_receive_wait_for_start_bit,
       WILL_FIRE_RL_uart_transmit_bit_cell_time_counter,
       WILL_FIRE_RL_uart_transmit_bit_counter,
       WILL_FIRE_RL_uart_transmit_buffer_load,
       WILL_FIRE_RL_uart_transmit_buffer_shift,
       WILL_FIRE_RL_uart_transmit_send_parity_bit,
       WILL_FIRE_RL_uart_transmit_send_start_bit,
       WILL_FIRE_RL_uart_transmit_send_stop_bit,
       WILL_FIRE_RL_uart_transmit_send_stop_bit1_5,
       WILL_FIRE_RL_uart_transmit_send_stop_bit2,
       WILL_FIRE_RL_uart_transmit_shift_next_bit,
       WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time,
       WILL_FIRE_RL_uart_transmit_wait_for_start_command,
       WILL_FIRE_RL_xmas_fsm_action_l42c32,
       WILL_FIRE_RL_xmas_fsm_action_l43c32,
       WILL_FIRE_RL_xmas_fsm_action_l44c32,
       WILL_FIRE_RL_xmas_fsm_action_l45c32,
       WILL_FIRE_RL_xmas_fsm_action_l46c32,
       WILL_FIRE_RL_xmas_fsm_action_l47c32,
       WILL_FIRE_RL_xmas_fsm_action_l48c32,
       WILL_FIRE_RL_xmas_fsm_action_l49c32,
       WILL_FIRE_RL_xmas_fsm_action_l50c32,
       WILL_FIRE_RL_xmas_fsm_action_l51c32,
       WILL_FIRE_RL_xmas_fsm_action_l52c32,
       WILL_FIRE_RL_xmas_fsm_action_l53c32,
       WILL_FIRE_RL_xmas_fsm_action_l54c32,
       WILL_FIRE_RL_xmas_fsm_action_l55c32,
       WILL_FIRE_RL_xmas_fsm_action_l56c32,
       WILL_FIRE_RL_xmas_fsm_action_l57c32,
       WILL_FIRE_RL_xmas_fsm_action_l58c32,
       WILL_FIRE_RL_xmas_fsm_action_l59c32,
       WILL_FIRE_RL_xmas_fsm_action_l60c32,
       WILL_FIRE_RL_xmas_fsm_action_l61c32,
       WILL_FIRE_RL_xmas_fsm_action_l62c32,
       WILL_FIRE_RL_xmas_fsm_action_l63c32,
       WILL_FIRE_RL_xmas_fsm_action_l64c32,
       WILL_FIRE_RL_xmas_fsm_action_l65c32,
       WILL_FIRE_RL_xmas_fsm_action_l66c32,
       WILL_FIRE_RL_xmas_fsm_fsm_start,
       WILL_FIRE_RL_xmas_fsm_idle_l40c27,
       WILL_FIRE_RL_xmas_fsm_idle_l40c27_1,
       WILL_FIRE_RL_xmas_fsm_restart,
       WILL_FIRE_RL_xmas_fsm_start_reg__dreg_update,
       WILL_FIRE_RL_xmas_fsm_state_every,
       WILL_FIRE_RL_xmas_fsm_state_fired__dreg_update,
       WILL_FIRE_RL_xmas_fsm_state_handle_abort,
       WILL_FIRE___me_check_34,
       WILL_FIRE___me_check_35,
       WILL_FIRE___me_check_36,
       WILL_FIRE___me_check_37,
       WILL_FIRE___me_check_38,
       WILL_FIRE___me_check_39,
       WILL_FIRE___me_check_40,
       WILL_FIRE___me_check_41,
       WILL_FIRE___me_check_42,
       WILL_FIRE___me_check_43,
       WILL_FIRE___me_check_44,
       WILL_FIRE___me_check_45,
       WILL_FIRE___me_check_46,
       WILL_FIRE___me_check_47,
       WILL_FIRE___me_check_48,
       WILL_FIRE___me_check_49,
       WILL_FIRE___me_check_50,
       WILL_FIRE___me_check_51,
       WILL_FIRE___me_check_52,
       WILL_FIRE___me_check_53,
       WILL_FIRE___me_check_54,
       WILL_FIRE___me_check_55,
       WILL_FIRE___me_check_56,
       WILL_FIRE___me_check_57,
       WILL_FIRE_operation_mode,
       WILL_FIRE_startup_value,
       WILL_FIRE_txrx_sin;

  // inputs to muxes for submodule ports
  reg [2 : 0] MUX_uart_rRecvState$write_1__VAL_3;
  wire [2 : 0] MUX_uart_rRecvState$write_1__VAL_1,
	       MUX_uart_rRecvState$write_1__VAL_2,
	       MUX_uart_rRecvState$write_1__VAL_4,
	       MUX_uart_rXmitState$write_1__VAL_1,
	       MUX_uart_rXmitState$write_1__VAL_2,
	       MUX_uart_rXmitState$write_1__VAL_3,
	       MUX_uart_rXmitState$write_1__VAL_4,
	       MUX_uart_rXmitState$write_1__VAL_5,
	       MUX_uart_rXmitState$write_1__VAL_6,
	       MUX_uart_rXmitState$write_1__VAL_7;
  wire MUX_transmit_state$write_1__SEL_1,
       MUX_uart_fifoXmit$enq_1__SEL_11,
       MUX_uart_fifoXmit$enq_1__SEL_15,
       MUX_uart_fifoXmit$enq_1__SEL_16,
       MUX_uart_fifoXmit$enq_1__SEL_17,
       MUX_uart_fifoXmit$enq_1__SEL_2,
       MUX_uart_fifoXmit$enq_1__SEL_3,
       MUX_uart_rRecvState$write_1__SEL_6,
       MUX_uart_rXmitDataOut$write_1__SEL_1,
       MUX_uart_rXmitDataOut$write_1__SEL_2,
       MUX_uart_rXmitDataOut$write_1__SEL_3,
       MUX_xmas_fsm_start_reg$write_1__SEL_1,
       MUX_xmas_fsm_state_mkFSMstate$write_1__SEL_1;

  // remaining internal signals
  wire [3 : 0] x__h2985, x__h4689, x__h6445, x__h6471;
  wire _dor2uart_pwXmitCellCountReset$EN_wset,
       uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29,
       xmas_fsm_abort_whas__57_AND_xmas_fsm_abort_wge_ETC___d302;

  // action method operation_mode
  assign RDY_operation_mode =
	     transmit_state == 2'd0 && !op_mode &&
	     xmas_fsm_abort_whas__57_AND_xmas_fsm_abort_wge_ETC___d302 &&
	     !xmas_fsm_start_reg ;
  assign CAN_FIRE_operation_mode =
	     transmit_state == 2'd0 && !op_mode &&
	     xmas_fsm_abort_whas__57_AND_xmas_fsm_abort_wge_ETC___d302 &&
	     !xmas_fsm_start_reg ;
  assign WILL_FIRE_operation_mode = EN_operation_mode ;

  // action method startup_value
  assign RDY_startup_value = transmit_state == 2'd0 && !op_mode ;
  assign CAN_FIRE_startup_value = transmit_state == 2'd0 && !op_mode ;
  assign WILL_FIRE_startup_value = EN_startup_value ;

  // action method txrx_sin
  assign CAN_FIRE_txrx_sin = 1'd1 ;
  assign WILL_FIRE_txrx_sin = 1'd1 ;

  // value method txrx_sout
  assign txrx_SOUT = uart_rXmitDataOut ;

  // submodule rule30
  mkRule30 rule30(.CLK(CLK),
		  .RST_N(RST_N),
		  .start_a(rule30$start_a),
		  .EN_start(rule30$EN_start),
		  .EN_getResult(rule30$EN_getResult),
		  .RDY_start(rule30$RDY_start),
		  .getResult(rule30$getResult),
		  .RDY_getResult(rule30$RDY_getResult));

  // submodule uart_baudGen_rBaudCounter
  Counter #(.width(32'd16), .init(16'd0)) uart_baudGen_rBaudCounter(.CLK(CLK),
								    .RST(RST_N),
								    .DATA_A(uart_baudGen_rBaudCounter$DATA_A),
								    .DATA_B(uart_baudGen_rBaudCounter$DATA_B),
								    .DATA_C(uart_baudGen_rBaudCounter$DATA_C),
								    .DATA_F(uart_baudGen_rBaudCounter$DATA_F),
								    .ADDA(uart_baudGen_rBaudCounter$ADDA),
								    .ADDB(uart_baudGen_rBaudCounter$ADDB),
								    .SETC(uart_baudGen_rBaudCounter$SETC),
								    .SETF(uart_baudGen_rBaudCounter$SETF),
								    .Q_OUT(uart_baudGen_rBaudCounter$Q_OUT));

  // submodule uart_baudGen_rBaudTickCounter
  Counter #(.width(32'd3),
	    .init(3'd0)) uart_baudGen_rBaudTickCounter(.CLK(CLK),
						       .RST(RST_N),
						       .DATA_A(uart_baudGen_rBaudTickCounter$DATA_A),
						       .DATA_B(uart_baudGen_rBaudTickCounter$DATA_B),
						       .DATA_C(uart_baudGen_rBaudTickCounter$DATA_C),
						       .DATA_F(uart_baudGen_rBaudTickCounter$DATA_F),
						       .ADDA(uart_baudGen_rBaudTickCounter$ADDA),
						       .ADDB(uart_baudGen_rBaudTickCounter$ADDB),
						       .SETC(uart_baudGen_rBaudTickCounter$SETC),
						       .SETF(uart_baudGen_rBaudTickCounter$SETF),
						       .Q_OUT(uart_baudGen_rBaudTickCounter$Q_OUT));

  // submodule uart_fifoRecv
  SizedFIFO #(.p1width(32'd8),
	      .p2depth(32'd3),
	      .p3cntr_width(32'd1),
	      .guarded(1'd1)) uart_fifoRecv(.RST(RST_N),
					    .CLK(CLK),
					    .D_IN(uart_fifoRecv$D_IN),
					    .ENQ(uart_fifoRecv$ENQ),
					    .DEQ(uart_fifoRecv$DEQ),
					    .CLR(uart_fifoRecv$CLR),
					    .D_OUT(),
					    .FULL_N(),
					    .EMPTY_N(uart_fifoRecv$EMPTY_N));

  // submodule uart_fifoXmit
  SizedFIFO #(.p1width(32'd8),
	      .p2depth(32'd3),
	      .p3cntr_width(32'd1),
	      .guarded(1'd1)) uart_fifoXmit(.RST(RST_N),
					    .CLK(CLK),
					    .D_IN(uart_fifoXmit$D_IN),
					    .ENQ(uart_fifoXmit$ENQ),
					    .DEQ(uart_fifoXmit$DEQ),
					    .CLR(uart_fifoXmit$CLR),
					    .D_OUT(uart_fifoXmit$D_OUT),
					    .FULL_N(uart_fifoXmit$FULL_N),
					    .EMPTY_N(uart_fifoXmit$EMPTY_N));

  // rule RL_dump_rx
  assign CAN_FIRE_RL_dump_rx = uart_fifoRecv$EMPTY_N ;
  assign WILL_FIRE_RL_dump_rx = uart_fifoRecv$EMPTY_N ;

  // rule RL_compute
  assign CAN_FIRE_RL_compute =
	     rule30$RDY_start && transmit_state == 2'd1 && !op_mode ;
  assign WILL_FIRE_RL_compute = CAN_FIRE_RL_compute ;

  // rule RL_uart_baudGen_baud_count_wire
  assign CAN_FIRE_RL_uart_baudGen_baud_count_wire = 1'd1 ;
  assign WILL_FIRE_RL_uart_baudGen_baud_count_wire = 1'd1 ;

  // rule RL_uart_baud_generator_clock_enable
  assign CAN_FIRE_RL_uart_baud_generator_clock_enable = 1'd1 ;
  assign WILL_FIRE_RL_uart_baud_generator_clock_enable = 1'd1 ;

  // rule RL_uart_receive_wait_for_start_bit
  assign CAN_FIRE_RL_uart_receive_wait_for_start_bit =
	     uart_rRecvState == 3'd0 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29 ;
  assign WILL_FIRE_RL_uart_receive_wait_for_start_bit =
	     CAN_FIRE_RL_uart_receive_wait_for_start_bit ;

  // rule RL_uart_receive_find_center_of_bit_cell
  assign CAN_FIRE_RL_uart_receive_find_center_of_bit_cell =
	     uart_rRecvState == 3'd1 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29 ;
  assign WILL_FIRE_RL_uart_receive_find_center_of_bit_cell =
	     CAN_FIRE_RL_uart_receive_find_center_of_bit_cell ;

  // rule RL_uart_receive_wait_bit_cell_time_for_sample
  assign CAN_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample =
	     uart_rRecvState == 3'd2 && uart_rRecvCellCount == 4'hF &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29 ;
  assign WILL_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample =
	     CAN_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample ;

  // rule RL_uart_receive_sample_pin
  assign CAN_FIRE_RL_uart_receive_sample_pin =
	     CAN_FIRE_RL_uart_receive_buffer_shift ;
  assign WILL_FIRE_RL_uart_receive_sample_pin =
	     CAN_FIRE_RL_uart_receive_buffer_shift ;

  // rule RL_uart_receive_parity_bit
  assign CAN_FIRE_RL_uart_receive_parity_bit =
	     uart_rRecvState == 3'd4 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29 ;
  assign WILL_FIRE_RL_uart_receive_parity_bit =
	     CAN_FIRE_RL_uart_receive_parity_bit ;

  // rule RL_uart_receive_stop_first_bit
  assign CAN_FIRE_RL_uart_receive_stop_first_bit =
	     uart_rRecvState == 3'd5 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29 ;
  assign WILL_FIRE_RL_uart_receive_stop_first_bit =
	     CAN_FIRE_RL_uart_receive_stop_first_bit ;

  // rule RL_uart_receive_bit_counter
  assign CAN_FIRE_RL_uart_receive_bit_counter = 1'd1 ;
  assign WILL_FIRE_RL_uart_receive_bit_counter = 1'd1 ;

  // rule RL_uart_receive_stop_last_bit
  assign CAN_FIRE_RL_uart_receive_stop_last_bit =
	     uart_rRecvState == 3'd6 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29 ;
  assign WILL_FIRE_RL_uart_receive_stop_last_bit =
	     CAN_FIRE_RL_uart_receive_stop_last_bit ;

  // rule RL_uart_receive_bit_cell_time_counter
  assign CAN_FIRE_RL_uart_receive_bit_cell_time_counter =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;
  assign WILL_FIRE_RL_uart_receive_bit_cell_time_counter =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;

  // rule RL_uart_receive_buffer_shift
  assign CAN_FIRE_RL_uart_receive_buffer_shift =
	     uart_rRecvState == 3'd3 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29 ;
  assign WILL_FIRE_RL_uart_receive_buffer_shift =
	     CAN_FIRE_RL_uart_receive_buffer_shift ;

  // rule RL_uart_transmit_wait_for_start_command
  assign CAN_FIRE_RL_uart_transmit_wait_for_start_command =
	     uart_rXmitState == 3'd0 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29 ;
  assign WILL_FIRE_RL_uart_transmit_wait_for_start_command =
	     CAN_FIRE_RL_uart_transmit_wait_for_start_command ;

  // rule RL_get_result
  assign CAN_FIRE_RL_get_result =
	     rule30$RDY_getResult && uart_fifoXmit$FULL_N &&
	     transmit_state == 2'd2 &&
	     !op_mode &&
	     xmas_fsm_abort_whas__57_AND_xmas_fsm_abort_wge_ETC___d302 &&
	     !xmas_fsm_start_reg ;
  assign WILL_FIRE_RL_get_result = CAN_FIRE_RL_get_result ;

  // rule RL_uart_transmit_send_start_bit
  assign CAN_FIRE_RL_uart_transmit_send_start_bit =
	     uart_rXmitState == 3'd1 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29 ;
  assign WILL_FIRE_RL_uart_transmit_send_start_bit =
	     CAN_FIRE_RL_uart_transmit_send_start_bit ;

  // rule RL_uart_transmit_wait_1_bit_cell_time
  assign CAN_FIRE_RL_uart_transmit_wait_1_bit_cell_time =
	     uart_rXmitState == 3'd2 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29 ;
  assign WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time =
	     CAN_FIRE_RL_uart_transmit_wait_1_bit_cell_time ;

  // rule RL_uart_transmit_bit_counter
  assign CAN_FIRE_RL_uart_transmit_bit_counter = 1'd1 ;
  assign WILL_FIRE_RL_uart_transmit_bit_counter = 1'd1 ;

  // rule RL_uart_transmit_shift_next_bit
  assign CAN_FIRE_RL_uart_transmit_shift_next_bit =
	     uart_rXmitState == 3'd3 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29 ;
  assign WILL_FIRE_RL_uart_transmit_shift_next_bit =
	     CAN_FIRE_RL_uart_transmit_shift_next_bit ;

  // rule RL_uart_transmit_buffer_load
  assign CAN_FIRE_RL_uart_transmit_buffer_load =
	     uart_fifoXmit$EMPTY_N && uart_pwXmitLoadBuffer$whas ;
  assign WILL_FIRE_RL_uart_transmit_buffer_load =
	     CAN_FIRE_RL_uart_transmit_buffer_load ;

  // rule RL_uart_transmit_buffer_shift
  assign CAN_FIRE_RL_uart_transmit_buffer_shift =
	     !uart_pwXmitLoadBuffer$whas &&
	     CAN_FIRE_RL_uart_transmit_shift_next_bit ;
  assign WILL_FIRE_RL_uart_transmit_buffer_shift =
	     CAN_FIRE_RL_uart_transmit_buffer_shift ;

  // rule RL_uart_transmit_send_parity_bit
  assign CAN_FIRE_RL_uart_transmit_send_parity_bit =
	     uart_rXmitState == 3'd7 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29 ;
  assign WILL_FIRE_RL_uart_transmit_send_parity_bit =
	     CAN_FIRE_RL_uart_transmit_send_parity_bit ;

  // rule RL_uart_transmit_send_stop_bit
  assign CAN_FIRE_RL_uart_transmit_send_stop_bit =
	     uart_rXmitState == 3'd4 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29 ;
  assign WILL_FIRE_RL_uart_transmit_send_stop_bit =
	     CAN_FIRE_RL_uart_transmit_send_stop_bit ;

  // rule RL_uart_transmit_send_stop_bit1_5
  assign CAN_FIRE_RL_uart_transmit_send_stop_bit1_5 =
	     uart_rXmitState == 3'd5 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29 ;
  assign WILL_FIRE_RL_uart_transmit_send_stop_bit1_5 =
	     CAN_FIRE_RL_uart_transmit_send_stop_bit1_5 ;

  // rule RL_uart_transmit_send_stop_bit2
  assign CAN_FIRE_RL_uart_transmit_send_stop_bit2 =
	     uart_rXmitState == 3'd6 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29 ;
  assign WILL_FIRE_RL_uart_transmit_send_stop_bit2 =
	     CAN_FIRE_RL_uart_transmit_send_stop_bit2 ;

  // rule RL_uart_transmit_bit_cell_time_counter
  assign CAN_FIRE_RL_uart_transmit_bit_cell_time_counter =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;
  assign WILL_FIRE_RL_uart_transmit_bit_cell_time_counter =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;

  // rule RL_uart_baudGen_baud_tick_count_wire
  assign CAN_FIRE_RL_uart_baudGen_baud_tick_count_wire = 1'd1 ;
  assign WILL_FIRE_RL_uart_baudGen_baud_tick_count_wire = 1'd1 ;

  // rule RL_uart_baudGen_assert_2x_baud_tick
  assign CAN_FIRE_RL_uart_baudGen_assert_2x_baud_tick =
	     uart_baudGen_rBaudTickCounter$Q_OUT == 3'd0 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29 ;
  assign WILL_FIRE_RL_uart_baudGen_assert_2x_baud_tick =
	     CAN_FIRE_RL_uart_baudGen_assert_2x_baud_tick ;

  // rule RL_uart_baudGen_count_baudtick_16x
  assign CAN_FIRE_RL_uart_baudGen_count_baudtick_16x =
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29 ;
  assign WILL_FIRE_RL_uart_baudGen_count_baudtick_16x =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;

  // rule RL_uart_fifoRecv__updateLevelCounter
  assign CAN_FIRE_RL_uart_fifoRecv__updateLevelCounter =
	     CAN_FIRE_RL_uart_receive_stop_last_bit != uart_fifoRecv$EMPTY_N ;
  assign WILL_FIRE_RL_uart_fifoRecv__updateLevelCounter =
	     CAN_FIRE_RL_uart_fifoRecv__updateLevelCounter ;

  // rule RL_xmas_fsm_restart
  assign CAN_FIRE_RL_xmas_fsm_restart =
	     xmas_fsm_start_reg_1 && !xmas_fsm_state_fired ;
  assign WILL_FIRE_RL_xmas_fsm_restart = CAN_FIRE_RL_xmas_fsm_restart ;

  // rule RL_xmas_fsm_action_l43c32
  assign CAN_FIRE_RL_xmas_fsm_action_l43c32 =
	     uart_fifoXmit$FULL_N && xmas_fsm_state_mkFSMstate == 5'd1 ;
  assign WILL_FIRE_RL_xmas_fsm_action_l43c32 =
	     CAN_FIRE_RL_xmas_fsm_action_l43c32 ;

  // rule RL_xmas_fsm_action_l44c32
  assign CAN_FIRE_RL_xmas_fsm_action_l44c32 =
	     uart_fifoXmit$FULL_N && xmas_fsm_state_mkFSMstate == 5'd2 ;
  assign WILL_FIRE_RL_xmas_fsm_action_l44c32 =
	     CAN_FIRE_RL_xmas_fsm_action_l44c32 ;

  // rule RL_xmas_fsm_action_l45c32
  assign CAN_FIRE_RL_xmas_fsm_action_l45c32 =
	     uart_fifoXmit$FULL_N && xmas_fsm_state_mkFSMstate == 5'd3 ;
  assign WILL_FIRE_RL_xmas_fsm_action_l45c32 =
	     CAN_FIRE_RL_xmas_fsm_action_l45c32 ;

  // rule RL_xmas_fsm_action_l46c32
  assign CAN_FIRE_RL_xmas_fsm_action_l46c32 =
	     uart_fifoXmit$FULL_N && xmas_fsm_state_mkFSMstate == 5'd4 ;
  assign WILL_FIRE_RL_xmas_fsm_action_l46c32 =
	     CAN_FIRE_RL_xmas_fsm_action_l46c32 ;

  // rule RL_xmas_fsm_action_l47c32
  assign CAN_FIRE_RL_xmas_fsm_action_l47c32 =
	     uart_fifoXmit$FULL_N && xmas_fsm_state_mkFSMstate == 5'd5 ;
  assign WILL_FIRE_RL_xmas_fsm_action_l47c32 =
	     CAN_FIRE_RL_xmas_fsm_action_l47c32 ;

  // rule RL_xmas_fsm_action_l48c32
  assign CAN_FIRE_RL_xmas_fsm_action_l48c32 =
	     uart_fifoXmit$FULL_N && xmas_fsm_state_mkFSMstate == 5'd6 ;
  assign WILL_FIRE_RL_xmas_fsm_action_l48c32 =
	     CAN_FIRE_RL_xmas_fsm_action_l48c32 ;

  // rule RL_xmas_fsm_action_l49c32
  assign CAN_FIRE_RL_xmas_fsm_action_l49c32 =
	     uart_fifoXmit$FULL_N && xmas_fsm_state_mkFSMstate == 5'd7 ;
  assign WILL_FIRE_RL_xmas_fsm_action_l49c32 =
	     CAN_FIRE_RL_xmas_fsm_action_l49c32 ;

  // rule RL_xmas_fsm_action_l50c32
  assign CAN_FIRE_RL_xmas_fsm_action_l50c32 =
	     uart_fifoXmit$FULL_N && xmas_fsm_state_mkFSMstate == 5'd8 ;
  assign WILL_FIRE_RL_xmas_fsm_action_l50c32 =
	     CAN_FIRE_RL_xmas_fsm_action_l50c32 ;

  // rule RL_xmas_fsm_action_l51c32
  assign CAN_FIRE_RL_xmas_fsm_action_l51c32 =
	     uart_fifoXmit$FULL_N && xmas_fsm_state_mkFSMstate == 5'd9 ;
  assign WILL_FIRE_RL_xmas_fsm_action_l51c32 =
	     CAN_FIRE_RL_xmas_fsm_action_l51c32 ;

  // rule RL_xmas_fsm_action_l52c32
  assign CAN_FIRE_RL_xmas_fsm_action_l52c32 =
	     uart_fifoXmit$FULL_N && xmas_fsm_state_mkFSMstate == 5'd10 ;
  assign WILL_FIRE_RL_xmas_fsm_action_l52c32 =
	     CAN_FIRE_RL_xmas_fsm_action_l52c32 ;

  // rule RL_xmas_fsm_action_l53c32
  assign CAN_FIRE_RL_xmas_fsm_action_l53c32 =
	     uart_fifoXmit$FULL_N && xmas_fsm_state_mkFSMstate == 5'd11 ;
  assign WILL_FIRE_RL_xmas_fsm_action_l53c32 =
	     CAN_FIRE_RL_xmas_fsm_action_l53c32 ;

  // rule RL_xmas_fsm_action_l54c32
  assign CAN_FIRE_RL_xmas_fsm_action_l54c32 =
	     uart_fifoXmit$FULL_N && xmas_fsm_state_mkFSMstate == 5'd12 ;
  assign WILL_FIRE_RL_xmas_fsm_action_l54c32 =
	     CAN_FIRE_RL_xmas_fsm_action_l54c32 ;

  // rule RL_xmas_fsm_action_l55c32
  assign CAN_FIRE_RL_xmas_fsm_action_l55c32 =
	     uart_fifoXmit$FULL_N && xmas_fsm_state_mkFSMstate == 5'd13 ;
  assign WILL_FIRE_RL_xmas_fsm_action_l55c32 =
	     CAN_FIRE_RL_xmas_fsm_action_l55c32 ;

  // rule RL_xmas_fsm_action_l56c32
  assign CAN_FIRE_RL_xmas_fsm_action_l56c32 =
	     uart_fifoXmit$FULL_N && xmas_fsm_state_mkFSMstate == 5'd14 ;
  assign WILL_FIRE_RL_xmas_fsm_action_l56c32 =
	     CAN_FIRE_RL_xmas_fsm_action_l56c32 ;

  // rule RL_xmas_fsm_action_l57c32
  assign CAN_FIRE_RL_xmas_fsm_action_l57c32 =
	     uart_fifoXmit$FULL_N && xmas_fsm_state_mkFSMstate == 5'd15 ;
  assign WILL_FIRE_RL_xmas_fsm_action_l57c32 =
	     CAN_FIRE_RL_xmas_fsm_action_l57c32 ;

  // rule RL_xmas_fsm_action_l58c32
  assign CAN_FIRE_RL_xmas_fsm_action_l58c32 =
	     uart_fifoXmit$FULL_N && xmas_fsm_state_mkFSMstate == 5'd16 ;
  assign WILL_FIRE_RL_xmas_fsm_action_l58c32 =
	     CAN_FIRE_RL_xmas_fsm_action_l58c32 ;

  // rule RL_xmas_fsm_action_l59c32
  assign CAN_FIRE_RL_xmas_fsm_action_l59c32 =
	     uart_fifoXmit$FULL_N && xmas_fsm_state_mkFSMstate == 5'd17 ;
  assign WILL_FIRE_RL_xmas_fsm_action_l59c32 =
	     CAN_FIRE_RL_xmas_fsm_action_l59c32 ;

  // rule RL_xmas_fsm_action_l60c32
  assign CAN_FIRE_RL_xmas_fsm_action_l60c32 =
	     uart_fifoXmit$FULL_N && xmas_fsm_state_mkFSMstate == 5'd18 ;
  assign WILL_FIRE_RL_xmas_fsm_action_l60c32 =
	     CAN_FIRE_RL_xmas_fsm_action_l60c32 ;

  // rule RL_xmas_fsm_action_l61c32
  assign CAN_FIRE_RL_xmas_fsm_action_l61c32 =
	     uart_fifoXmit$FULL_N && xmas_fsm_state_mkFSMstate == 5'd19 ;
  assign WILL_FIRE_RL_xmas_fsm_action_l61c32 =
	     CAN_FIRE_RL_xmas_fsm_action_l61c32 ;

  // rule RL_xmas_fsm_action_l62c32
  assign CAN_FIRE_RL_xmas_fsm_action_l62c32 =
	     uart_fifoXmit$FULL_N && xmas_fsm_state_mkFSMstate == 5'd20 ;
  assign WILL_FIRE_RL_xmas_fsm_action_l62c32 =
	     CAN_FIRE_RL_xmas_fsm_action_l62c32 ;

  // rule RL_xmas_fsm_action_l63c32
  assign CAN_FIRE_RL_xmas_fsm_action_l63c32 =
	     uart_fifoXmit$FULL_N && xmas_fsm_state_mkFSMstate == 5'd21 ;
  assign WILL_FIRE_RL_xmas_fsm_action_l63c32 =
	     CAN_FIRE_RL_xmas_fsm_action_l63c32 ;

  // rule RL_xmas_fsm_action_l64c32
  assign CAN_FIRE_RL_xmas_fsm_action_l64c32 =
	     uart_fifoXmit$FULL_N && xmas_fsm_state_mkFSMstate == 5'd22 ;
  assign WILL_FIRE_RL_xmas_fsm_action_l64c32 =
	     CAN_FIRE_RL_xmas_fsm_action_l64c32 ;

  // rule RL_xmas_fsm_action_l65c32
  assign CAN_FIRE_RL_xmas_fsm_action_l65c32 =
	     uart_fifoXmit$FULL_N && xmas_fsm_state_mkFSMstate == 5'd23 ;
  assign WILL_FIRE_RL_xmas_fsm_action_l65c32 =
	     CAN_FIRE_RL_xmas_fsm_action_l65c32 ;

  // rule RL_xmas_fsm_action_l66c32
  assign CAN_FIRE_RL_xmas_fsm_action_l66c32 =
	     uart_fifoXmit$FULL_N && xmas_fsm_state_mkFSMstate == 5'd24 ;
  assign WILL_FIRE_RL_xmas_fsm_action_l66c32 =
	     CAN_FIRE_RL_xmas_fsm_action_l66c32 ;

  // rule __me_check_35
  assign CAN_FIRE___me_check_35 = 1'b1 ;
  assign WILL_FIRE___me_check_35 = 1'b1 ;

  // rule __me_check_36
  assign CAN_FIRE___me_check_36 = 1'b1 ;
  assign WILL_FIRE___me_check_36 = 1'b1 ;

  // rule __me_check_37
  assign CAN_FIRE___me_check_37 = 1'b1 ;
  assign WILL_FIRE___me_check_37 = 1'b1 ;

  // rule __me_check_38
  assign CAN_FIRE___me_check_38 = 1'b1 ;
  assign WILL_FIRE___me_check_38 = 1'b1 ;

  // rule __me_check_39
  assign CAN_FIRE___me_check_39 = 1'b1 ;
  assign WILL_FIRE___me_check_39 = 1'b1 ;

  // rule __me_check_40
  assign CAN_FIRE___me_check_40 = 1'b1 ;
  assign WILL_FIRE___me_check_40 = 1'b1 ;

  // rule __me_check_41
  assign CAN_FIRE___me_check_41 = 1'b1 ;
  assign WILL_FIRE___me_check_41 = 1'b1 ;

  // rule __me_check_43
  assign CAN_FIRE___me_check_43 = 1'b1 ;
  assign WILL_FIRE___me_check_43 = 1'b1 ;

  // rule __me_check_42
  assign CAN_FIRE___me_check_42 = 1'b1 ;
  assign WILL_FIRE___me_check_42 = 1'b1 ;

  // rule __me_check_44
  assign CAN_FIRE___me_check_44 = 1'b1 ;
  assign WILL_FIRE___me_check_44 = 1'b1 ;

  // rule __me_check_45
  assign CAN_FIRE___me_check_45 = 1'b1 ;
  assign WILL_FIRE___me_check_45 = 1'b1 ;

  // rule __me_check_46
  assign CAN_FIRE___me_check_46 = 1'b1 ;
  assign WILL_FIRE___me_check_46 = 1'b1 ;

  // rule __me_check_47
  assign CAN_FIRE___me_check_47 = 1'b1 ;
  assign WILL_FIRE___me_check_47 = 1'b1 ;

  // rule __me_check_48
  assign CAN_FIRE___me_check_48 = 1'b1 ;
  assign WILL_FIRE___me_check_48 = 1'b1 ;

  // rule __me_check_49
  assign CAN_FIRE___me_check_49 = 1'b1 ;
  assign WILL_FIRE___me_check_49 = 1'b1 ;

  // rule __me_check_51
  assign CAN_FIRE___me_check_51 = 1'b1 ;
  assign WILL_FIRE___me_check_51 = 1'b1 ;

  // rule __me_check_50
  assign CAN_FIRE___me_check_50 = 1'b1 ;
  assign WILL_FIRE___me_check_50 = 1'b1 ;

  // rule __me_check_52
  assign CAN_FIRE___me_check_52 = 1'b1 ;
  assign WILL_FIRE___me_check_52 = 1'b1 ;

  // rule __me_check_53
  assign CAN_FIRE___me_check_53 = 1'b1 ;
  assign WILL_FIRE___me_check_53 = 1'b1 ;

  // rule __me_check_54
  assign CAN_FIRE___me_check_54 = 1'b1 ;
  assign WILL_FIRE___me_check_54 = 1'b1 ;

  // rule __me_check_55
  assign CAN_FIRE___me_check_55 = 1'b1 ;
  assign WILL_FIRE___me_check_55 = 1'b1 ;

  // rule __me_check_56
  assign CAN_FIRE___me_check_56 = 1'b1 ;
  assign WILL_FIRE___me_check_56 = 1'b1 ;

  // rule __me_check_57
  assign CAN_FIRE___me_check_57 = 1'b1 ;
  assign WILL_FIRE___me_check_57 = 1'b1 ;

  // rule RL_xmas_fsm_idle_l40c27_1
  assign CAN_FIRE_RL_xmas_fsm_idle_l40c27_1 =
	     !op_mode && xmas_fsm_state_mkFSMstate == 5'd25 ;
  assign WILL_FIRE_RL_xmas_fsm_idle_l40c27_1 =
	     CAN_FIRE_RL_xmas_fsm_idle_l40c27_1 ;

  // rule RL_xmas_fsm_fsm_start
  assign CAN_FIRE_RL_xmas_fsm_fsm_start =
	     (op_mode && xmas_fsm_state_mkFSMstate == 5'd0 ||
	      op_mode && xmas_fsm_state_mkFSMstate == 5'd27 ||
	      !op_mode && xmas_fsm_state_mkFSMstate == 5'd0 ||
	      !op_mode &&
	      (xmas_fsm_state_mkFSMstate == 5'd25 ||
	       xmas_fsm_state_mkFSMstate == 5'd27)) &&
	     (!xmas_fsm_start_reg_1 || xmas_fsm_state_fired) &&
	     xmas_fsm_start_reg ;
  assign WILL_FIRE_RL_xmas_fsm_fsm_start = CAN_FIRE_RL_xmas_fsm_fsm_start ;

  // rule RL_xmas_fsm_action_l42c32
  assign CAN_FIRE_RL_xmas_fsm_action_l42c32 =
	     uart_fifoXmit$FULL_N &&
	     (op_mode && xmas_fsm_start_wire$whas &&
	      xmas_fsm_state_mkFSMstate == 5'd0 ||
	      op_mode && xmas_fsm_state_mkFSMstate == 5'd25) ;
  assign WILL_FIRE_RL_xmas_fsm_action_l42c32 =
	     CAN_FIRE_RL_xmas_fsm_action_l42c32 ;

  // rule __me_check_34
  assign CAN_FIRE___me_check_34 = 1'b1 ;
  assign WILL_FIRE___me_check_34 = 1'b1 ;

  // rule RL_uart_fifoXmit__updateLevelCounter
  assign CAN_FIRE_RL_uart_fifoXmit__updateLevelCounter =
	     uart_fifoXmit_r_enq$whas !=
	     CAN_FIRE_RL_uart_transmit_buffer_load ;
  assign WILL_FIRE_RL_uart_fifoXmit__updateLevelCounter =
	     CAN_FIRE_RL_uart_fifoXmit__updateLevelCounter ;

  // rule RL_xmas_fsm_idle_l40c27
  assign CAN_FIRE_RL_xmas_fsm_idle_l40c27 =
	     !op_mode && xmas_fsm_start_wire$whas &&
	     xmas_fsm_state_mkFSMstate == 5'd0 ;
  assign WILL_FIRE_RL_xmas_fsm_idle_l40c27 =
	     CAN_FIRE_RL_xmas_fsm_idle_l40c27 ;

  // rule RL_xmas_fsm_start_reg__dreg_update
  assign CAN_FIRE_RL_xmas_fsm_start_reg__dreg_update = 1'd1 ;
  assign WILL_FIRE_RL_xmas_fsm_start_reg__dreg_update = 1'd1 ;

  // rule RL_xmas_fsm_state_handle_abort
  assign CAN_FIRE_RL_xmas_fsm_state_handle_abort = 1'b0 ;
  assign WILL_FIRE_RL_xmas_fsm_state_handle_abort = 1'b0 ;

  // rule RL_xmas_fsm_state_every
  assign CAN_FIRE_RL_xmas_fsm_state_every = 1'd1 ;
  assign WILL_FIRE_RL_xmas_fsm_state_every = 1'd1 ;

  // rule RL_xmas_fsm_state_fired__dreg_update
  assign CAN_FIRE_RL_xmas_fsm_state_fired__dreg_update = 1'd1 ;
  assign WILL_FIRE_RL_xmas_fsm_state_fired__dreg_update = 1'd1 ;

  // inputs to muxes for submodule ports
  assign MUX_transmit_state$write_1__SEL_1 =
	     WILL_FIRE_RL_get_result || EN_startup_value ;
  assign MUX_uart_fifoXmit$enq_1__SEL_2 =
	     WILL_FIRE_RL_xmas_fsm_action_l66c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l65c32 ;
  assign MUX_uart_fifoXmit$enq_1__SEL_3 =
	     WILL_FIRE_RL_xmas_fsm_action_l56c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l52c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l47c32 ;
  assign MUX_uart_fifoXmit$enq_1__SEL_11 =
	     WILL_FIRE_RL_xmas_fsm_action_l60c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l50c32 ;
  assign MUX_uart_fifoXmit$enq_1__SEL_15 =
	     WILL_FIRE_RL_xmas_fsm_action_l59c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l45c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l44c32 ;
  assign MUX_uart_fifoXmit$enq_1__SEL_16 =
	     WILL_FIRE_RL_xmas_fsm_action_l63c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l51c32 ;
  assign MUX_uart_fifoXmit$enq_1__SEL_17 =
	     WILL_FIRE_RL_xmas_fsm_action_l61c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l58c32 ;
  assign MUX_uart_rRecvState$write_1__SEL_6 =
	     WILL_FIRE_RL_uart_receive_parity_bit ||
	     WILL_FIRE_RL_uart_receive_sample_pin ;
  assign MUX_uart_rXmitDataOut$write_1__SEL_1 =
	     WILL_FIRE_RL_uart_transmit_shift_next_bit ||
	     WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time ;
  assign MUX_uart_rXmitDataOut$write_1__SEL_2 =
	     WILL_FIRE_RL_uart_transmit_send_parity_bit ||
	     WILL_FIRE_RL_uart_transmit_send_start_bit ;
  assign MUX_uart_rXmitDataOut$write_1__SEL_3 =
	     WILL_FIRE_RL_uart_transmit_send_stop_bit2 ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit1_5 ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit ||
	     WILL_FIRE_RL_uart_transmit_wait_for_start_command ;
  assign MUX_xmas_fsm_start_reg$write_1__SEL_1 =
	     EN_operation_mode && operation_mode_arg == 8'hA5 ;
  assign MUX_xmas_fsm_state_mkFSMstate$write_1__SEL_1 =
	     WILL_FIRE_RL_xmas_fsm_idle_l40c27_1 ||
	     WILL_FIRE_RL_xmas_fsm_idle_l40c27 ;
  assign MUX_uart_rRecvState$write_1__VAL_1 = uart_rRecvData ? 3'd0 : 3'd1 ;
  assign MUX_uart_rRecvState$write_1__VAL_2 =
	     (uart_rRecvCellCount == 4'h4) ?
	       (uart_rRecvData ? 3'd0 : 3'd2) :
	       3'd1 ;
  always@(uart_rRecvBitCount)
  begin
    case (uart_rRecvBitCount)
      4'd8, 4'd9, 4'd10: MUX_uart_rRecvState$write_1__VAL_3 = 3'd6;
      default: MUX_uart_rRecvState$write_1__VAL_3 = 3'd3;
    endcase
  end
  assign MUX_uart_rRecvState$write_1__VAL_4 = uart_rRecvData ? 3'd2 : 3'd0 ;
  assign MUX_uart_rXmitState$write_1__VAL_1 =
	     uart_fifoXmit$EMPTY_N ? 3'd1 : 3'd0 ;
  assign MUX_uart_rXmitState$write_1__VAL_2 =
	     (uart_rXmitCellCount == 4'hF) ? 3'd2 : 3'd1 ;
  assign MUX_uart_rXmitState$write_1__VAL_3 =
	     (uart_rXmitCellCount == 4'hF) ?
	       ((uart_rXmitBitCount == 4'd7) ? 3'd4 : 3'd3) :
	       3'd2 ;
  assign MUX_uart_rXmitState$write_1__VAL_4 =
	     (uart_rXmitCellCount == 4'hF) ? 3'd4 : 3'd7 ;
  assign MUX_uart_rXmitState$write_1__VAL_5 =
	     (uart_rXmitCellCount == 4'hF) ? 3'd0 : 3'd4 ;
  assign MUX_uart_rXmitState$write_1__VAL_6 =
	     (uart_rXmitCellCount == 4'h7) ? 3'd0 : 3'd5 ;
  assign MUX_uart_rXmitState$write_1__VAL_7 =
	     (uart_rXmitCellCount == 4'hF) ? 3'd0 : 3'd6 ;

  // inlined wires
  assign xmas_fsm_start_wire$whas =
	     WILL_FIRE_RL_xmas_fsm_fsm_start ||
	     WILL_FIRE_RL_xmas_fsm_restart ;
  assign uart_pwRecvCellCountReset$whas =
	     WILL_FIRE_RL_uart_receive_find_center_of_bit_cell &&
	     uart_rRecvCellCount == 4'h4 ||
	     WILL_FIRE_RL_uart_receive_stop_last_bit ||
	     WILL_FIRE_RL_uart_receive_stop_first_bit ||
	     WILL_FIRE_RL_uart_receive_parity_bit ||
	     WILL_FIRE_RL_uart_receive_sample_pin ||
	     WILL_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample ||
	     WILL_FIRE_RL_uart_receive_wait_for_start_bit ;
  assign uart_pwRecvResetBitCount$whas =
	     WILL_FIRE_RL_uart_receive_wait_for_start_bit && uart_rRecvData ;
  assign uart_pwRecvEnableBitCount$whas =
	     WILL_FIRE_RL_uart_receive_stop_first_bit ||
	     WILL_FIRE_RL_uart_receive_parity_bit ||
	     WILL_FIRE_RL_uart_receive_sample_pin ;
  assign uart_fifoXmit_r_enq$whas =
	     WILL_FIRE_RL_get_result || WILL_FIRE_RL_xmas_fsm_action_l66c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l65c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l64c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l63c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l62c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l61c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l60c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l59c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l58c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l57c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l56c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l55c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l54c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l53c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l52c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l51c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l50c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l49c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l48c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l47c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l46c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l45c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l44c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l43c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l42c32 ;
  assign uart_pwXmitCellCountReset$whas =
	     WILL_FIRE_RL_uart_transmit_wait_for_start_command &&
	     uart_fifoXmit$EMPTY_N ||
	     _dor2uart_pwXmitCellCountReset$EN_wset &&
	     uart_rXmitCellCount == 4'hF ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit1_5 &&
	     uart_rXmitCellCount == 4'h7 ;
  assign uart_pwXmitEnableBitCount$whas =
	     WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time &&
	     uart_rXmitCellCount == 4'hF &&
	     uart_rXmitBitCount != 4'd7 ;
  assign uart_pwXmitLoadBuffer$whas =
	     WILL_FIRE_RL_uart_transmit_wait_for_start_command &&
	     uart_fifoXmit$EMPTY_N ;
  assign xmas_fsm_state_set_pw$whas =
	     WILL_FIRE_RL_xmas_fsm_idle_l40c27_1 ||
	     WILL_FIRE_RL_xmas_fsm_idle_l40c27 ||
	     WILL_FIRE_RL_xmas_fsm_action_l66c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l65c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l64c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l63c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l62c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l61c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l60c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l59c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l58c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l57c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l56c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l55c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l54c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l53c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l52c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l51c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l50c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l49c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l48c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l47c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l46c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l45c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l44c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l43c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l42c32 ;

  // register a
  assign a$D_IN = EN_startup_value ? startup_value_v : rule30$getResult ;
  assign a$EN = EN_startup_value || WILL_FIRE_RL_get_result ;

  // register op_mode
  assign op_mode$D_IN = 1'd1 ;
  assign op_mode$EN = MUX_xmas_fsm_start_reg$write_1__SEL_1 ;

  // register transmit_state
  assign transmit_state$D_IN =
	     MUX_transmit_state$write_1__SEL_1 ? 2'd1 : 2'd2 ;
  assign transmit_state$EN =
	     WILL_FIRE_RL_get_result || EN_startup_value ||
	     WILL_FIRE_RL_compute ;

  // register uart_rRecvBitCount
  assign uart_rRecvBitCount$D_IN =
	     uart_pwRecvResetBitCount$whas ? 4'd0 : x__h4689 ;
  assign uart_rRecvBitCount$EN =
	     uart_pwRecvResetBitCount$whas || uart_pwRecvEnableBitCount$whas ;

  // register uart_rRecvCellCount
  assign uart_rRecvCellCount$D_IN =
	     uart_pwRecvCellCountReset$whas ? 4'd0 : x__h2985 ;
  assign uart_rRecvCellCount$EN =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;

  // register uart_rRecvData
  assign uart_rRecvData$D_IN = txrx_SIN ;
  assign uart_rRecvData$EN = 1'd1 ;

  // register uart_rRecvState
  always@(WILL_FIRE_RL_uart_receive_wait_for_start_bit or
	  MUX_uart_rRecvState$write_1__VAL_1 or
	  WILL_FIRE_RL_uart_receive_find_center_of_bit_cell or
	  MUX_uart_rRecvState$write_1__VAL_2 or
	  WILL_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample or
	  MUX_uart_rRecvState$write_1__VAL_3 or
	  WILL_FIRE_RL_uart_receive_stop_first_bit or
	  MUX_uart_rRecvState$write_1__VAL_4 or
	  WILL_FIRE_RL_uart_receive_stop_last_bit or
	  MUX_uart_rRecvState$write_1__SEL_6)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_uart_receive_wait_for_start_bit:
	  uart_rRecvState$D_IN = MUX_uart_rRecvState$write_1__VAL_1;
      WILL_FIRE_RL_uart_receive_find_center_of_bit_cell:
	  uart_rRecvState$D_IN = MUX_uart_rRecvState$write_1__VAL_2;
      WILL_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample:
	  uart_rRecvState$D_IN = MUX_uart_rRecvState$write_1__VAL_3;
      WILL_FIRE_RL_uart_receive_stop_first_bit:
	  uart_rRecvState$D_IN = MUX_uart_rRecvState$write_1__VAL_4;
      WILL_FIRE_RL_uart_receive_stop_last_bit: uart_rRecvState$D_IN = 3'd0;
      MUX_uart_rRecvState$write_1__SEL_6: uart_rRecvState$D_IN = 3'd2;
      default: uart_rRecvState$D_IN = 3'b010 /* unspecified value */ ;
    endcase
  end
  assign uart_rRecvState$EN =
	     WILL_FIRE_RL_uart_receive_wait_for_start_bit ||
	     WILL_FIRE_RL_uart_receive_find_center_of_bit_cell ||
	     WILL_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample ||
	     WILL_FIRE_RL_uart_receive_stop_first_bit ||
	     WILL_FIRE_RL_uart_receive_stop_last_bit ||
	     WILL_FIRE_RL_uart_receive_parity_bit ||
	     WILL_FIRE_RL_uart_receive_sample_pin ;

  // register uart_rXmitBitCount
  assign uart_rXmitBitCount$D_IN =
	     CAN_FIRE_RL_uart_transmit_wait_for_start_command ?
	       4'd0 :
	       x__h6471 ;
  assign uart_rXmitBitCount$EN =
	     CAN_FIRE_RL_uart_transmit_wait_for_start_command ||
	     uart_pwXmitEnableBitCount$whas ;

  // register uart_rXmitCellCount
  assign uart_rXmitCellCount$D_IN =
	     uart_pwXmitCellCountReset$whas ? 4'd0 : x__h6445 ;
  assign uart_rXmitCellCount$EN =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;

  // register uart_rXmitDataOut
  always@(MUX_uart_rXmitDataOut$write_1__SEL_1 or
	  uart_vrXmitBuffer_0 or
	  MUX_uart_rXmitDataOut$write_1__SEL_2 or
	  MUX_uart_rXmitDataOut$write_1__SEL_3)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_uart_rXmitDataOut$write_1__SEL_1:
	  uart_rXmitDataOut$D_IN = uart_vrXmitBuffer_0;
      MUX_uart_rXmitDataOut$write_1__SEL_2: uart_rXmitDataOut$D_IN = 1'b0;
      MUX_uart_rXmitDataOut$write_1__SEL_3: uart_rXmitDataOut$D_IN = 1'b1;
      default: uart_rXmitDataOut$D_IN = 1'b0 /* unspecified value */ ;
    endcase
  end
  assign uart_rXmitDataOut$EN =
	     WILL_FIRE_RL_uart_transmit_shift_next_bit ||
	     WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time ||
	     WILL_FIRE_RL_uart_transmit_send_parity_bit ||
	     WILL_FIRE_RL_uart_transmit_send_start_bit ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit2 ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit1_5 ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit ||
	     WILL_FIRE_RL_uart_transmit_wait_for_start_command ;

  // register uart_rXmitState
  always@(WILL_FIRE_RL_uart_transmit_wait_for_start_command or
	  MUX_uart_rXmitState$write_1__VAL_1 or
	  WILL_FIRE_RL_uart_transmit_send_start_bit or
	  MUX_uart_rXmitState$write_1__VAL_2 or
	  WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time or
	  MUX_uart_rXmitState$write_1__VAL_3 or
	  WILL_FIRE_RL_uart_transmit_send_parity_bit or
	  MUX_uart_rXmitState$write_1__VAL_4 or
	  WILL_FIRE_RL_uart_transmit_send_stop_bit or
	  MUX_uart_rXmitState$write_1__VAL_5 or
	  WILL_FIRE_RL_uart_transmit_send_stop_bit1_5 or
	  MUX_uart_rXmitState$write_1__VAL_6 or
	  WILL_FIRE_RL_uart_transmit_send_stop_bit2 or
	  MUX_uart_rXmitState$write_1__VAL_7 or
	  WILL_FIRE_RL_uart_transmit_shift_next_bit)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_uart_transmit_wait_for_start_command:
	  uart_rXmitState$D_IN = MUX_uart_rXmitState$write_1__VAL_1;
      WILL_FIRE_RL_uart_transmit_send_start_bit:
	  uart_rXmitState$D_IN = MUX_uart_rXmitState$write_1__VAL_2;
      WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time:
	  uart_rXmitState$D_IN = MUX_uart_rXmitState$write_1__VAL_3;
      WILL_FIRE_RL_uart_transmit_send_parity_bit:
	  uart_rXmitState$D_IN = MUX_uart_rXmitState$write_1__VAL_4;
      WILL_FIRE_RL_uart_transmit_send_stop_bit:
	  uart_rXmitState$D_IN = MUX_uart_rXmitState$write_1__VAL_5;
      WILL_FIRE_RL_uart_transmit_send_stop_bit1_5:
	  uart_rXmitState$D_IN = MUX_uart_rXmitState$write_1__VAL_6;
      WILL_FIRE_RL_uart_transmit_send_stop_bit2:
	  uart_rXmitState$D_IN = MUX_uart_rXmitState$write_1__VAL_7;
      WILL_FIRE_RL_uart_transmit_shift_next_bit: uart_rXmitState$D_IN = 3'd2;
      default: uart_rXmitState$D_IN = 3'b010 /* unspecified value */ ;
    endcase
  end
  assign uart_rXmitState$EN =
	     WILL_FIRE_RL_uart_transmit_wait_for_start_command ||
	     WILL_FIRE_RL_uart_transmit_send_start_bit ||
	     WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time ||
	     WILL_FIRE_RL_uart_transmit_send_parity_bit ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit1_5 ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit2 ||
	     WILL_FIRE_RL_uart_transmit_shift_next_bit ;

  // register uart_vrRecvBuffer_0
  assign uart_vrRecvBuffer_0$D_IN = uart_vrRecvBuffer_1 ;
  assign uart_vrRecvBuffer_0$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrRecvBuffer_1
  assign uart_vrRecvBuffer_1$D_IN = uart_vrRecvBuffer_2 ;
  assign uart_vrRecvBuffer_1$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrRecvBuffer_2
  assign uart_vrRecvBuffer_2$D_IN = uart_vrRecvBuffer_3 ;
  assign uart_vrRecvBuffer_2$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrRecvBuffer_3
  assign uart_vrRecvBuffer_3$D_IN = uart_vrRecvBuffer_4 ;
  assign uart_vrRecvBuffer_3$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrRecvBuffer_4
  assign uart_vrRecvBuffer_4$D_IN = uart_vrRecvBuffer_5 ;
  assign uart_vrRecvBuffer_4$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrRecvBuffer_5
  assign uart_vrRecvBuffer_5$D_IN = uart_vrRecvBuffer_6 ;
  assign uart_vrRecvBuffer_5$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrRecvBuffer_6
  assign uart_vrRecvBuffer_6$D_IN = uart_vrRecvBuffer_7 ;
  assign uart_vrRecvBuffer_6$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrRecvBuffer_7
  assign uart_vrRecvBuffer_7$D_IN = uart_rRecvData ;
  assign uart_vrRecvBuffer_7$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrXmitBuffer_0
  assign uart_vrXmitBuffer_0$D_IN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ?
	       uart_fifoXmit$D_OUT[0] :
	       uart_vrXmitBuffer_1 ;
  assign uart_vrXmitBuffer_0$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // register uart_vrXmitBuffer_1
  assign uart_vrXmitBuffer_1$D_IN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ?
	       uart_fifoXmit$D_OUT[1] :
	       uart_vrXmitBuffer_2 ;
  assign uart_vrXmitBuffer_1$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // register uart_vrXmitBuffer_2
  assign uart_vrXmitBuffer_2$D_IN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ?
	       uart_fifoXmit$D_OUT[2] :
	       uart_vrXmitBuffer_3 ;
  assign uart_vrXmitBuffer_2$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // register uart_vrXmitBuffer_3
  assign uart_vrXmitBuffer_3$D_IN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ?
	       uart_fifoXmit$D_OUT[3] :
	       uart_vrXmitBuffer_4 ;
  assign uart_vrXmitBuffer_3$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // register uart_vrXmitBuffer_4
  assign uart_vrXmitBuffer_4$D_IN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ?
	       uart_fifoXmit$D_OUT[4] :
	       uart_vrXmitBuffer_5 ;
  assign uart_vrXmitBuffer_4$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // register uart_vrXmitBuffer_5
  assign uart_vrXmitBuffer_5$D_IN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ?
	       uart_fifoXmit$D_OUT[5] :
	       uart_vrXmitBuffer_6 ;
  assign uart_vrXmitBuffer_5$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // register uart_vrXmitBuffer_6
  assign uart_vrXmitBuffer_6$D_IN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ?
	       uart_fifoXmit$D_OUT[6] :
	       uart_vrXmitBuffer_7 ;
  assign uart_vrXmitBuffer_6$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // register uart_vrXmitBuffer_7
  assign uart_vrXmitBuffer_7$D_IN =
	     !WILL_FIRE_RL_uart_transmit_buffer_load ||
	     uart_fifoXmit$D_OUT[7] ;
  assign uart_vrXmitBuffer_7$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // register xmas_fsm_start_reg
  assign xmas_fsm_start_reg$D_IN = MUX_xmas_fsm_start_reg$write_1__SEL_1 ;
  assign xmas_fsm_start_reg$EN =
	     EN_operation_mode && operation_mode_arg == 8'hA5 ||
	     WILL_FIRE_RL_xmas_fsm_fsm_start ;

  // register xmas_fsm_start_reg_1
  assign xmas_fsm_start_reg_1$D_IN = xmas_fsm_start_wire$whas ;
  assign xmas_fsm_start_reg_1$EN = 1'd1 ;

  // register xmas_fsm_state_fired
  assign xmas_fsm_state_fired$D_IN = xmas_fsm_state_set_pw$whas ;
  assign xmas_fsm_state_fired$EN = 1'd1 ;

  // register xmas_fsm_state_mkFSMstate
  always@(MUX_xmas_fsm_state_mkFSMstate$write_1__SEL_1 or
	  WILL_FIRE_RL_xmas_fsm_action_l42c32 or
	  WILL_FIRE_RL_xmas_fsm_action_l43c32 or
	  WILL_FIRE_RL_xmas_fsm_action_l44c32 or
	  WILL_FIRE_RL_xmas_fsm_action_l45c32 or
	  WILL_FIRE_RL_xmas_fsm_action_l46c32 or
	  WILL_FIRE_RL_xmas_fsm_action_l47c32 or
	  WILL_FIRE_RL_xmas_fsm_action_l48c32 or
	  WILL_FIRE_RL_xmas_fsm_action_l49c32 or
	  WILL_FIRE_RL_xmas_fsm_action_l50c32 or
	  WILL_FIRE_RL_xmas_fsm_action_l51c32 or
	  WILL_FIRE_RL_xmas_fsm_action_l52c32 or
	  WILL_FIRE_RL_xmas_fsm_action_l53c32 or
	  WILL_FIRE_RL_xmas_fsm_action_l54c32 or
	  WILL_FIRE_RL_xmas_fsm_action_l55c32 or
	  WILL_FIRE_RL_xmas_fsm_action_l56c32 or
	  WILL_FIRE_RL_xmas_fsm_action_l57c32 or
	  WILL_FIRE_RL_xmas_fsm_action_l58c32 or
	  WILL_FIRE_RL_xmas_fsm_action_l59c32 or
	  WILL_FIRE_RL_xmas_fsm_action_l60c32 or
	  WILL_FIRE_RL_xmas_fsm_action_l61c32 or
	  WILL_FIRE_RL_xmas_fsm_action_l62c32 or
	  WILL_FIRE_RL_xmas_fsm_action_l63c32 or
	  WILL_FIRE_RL_xmas_fsm_action_l64c32 or
	  WILL_FIRE_RL_xmas_fsm_action_l65c32 or
	  WILL_FIRE_RL_xmas_fsm_action_l66c32)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_xmas_fsm_state_mkFSMstate$write_1__SEL_1:
	  xmas_fsm_state_mkFSMstate$D_IN = 5'd0;
      WILL_FIRE_RL_xmas_fsm_action_l42c32:
	  xmas_fsm_state_mkFSMstate$D_IN = 5'd1;
      WILL_FIRE_RL_xmas_fsm_action_l43c32:
	  xmas_fsm_state_mkFSMstate$D_IN = 5'd2;
      WILL_FIRE_RL_xmas_fsm_action_l44c32:
	  xmas_fsm_state_mkFSMstate$D_IN = 5'd3;
      WILL_FIRE_RL_xmas_fsm_action_l45c32:
	  xmas_fsm_state_mkFSMstate$D_IN = 5'd4;
      WILL_FIRE_RL_xmas_fsm_action_l46c32:
	  xmas_fsm_state_mkFSMstate$D_IN = 5'd5;
      WILL_FIRE_RL_xmas_fsm_action_l47c32:
	  xmas_fsm_state_mkFSMstate$D_IN = 5'd6;
      WILL_FIRE_RL_xmas_fsm_action_l48c32:
	  xmas_fsm_state_mkFSMstate$D_IN = 5'd7;
      WILL_FIRE_RL_xmas_fsm_action_l49c32:
	  xmas_fsm_state_mkFSMstate$D_IN = 5'd8;
      WILL_FIRE_RL_xmas_fsm_action_l50c32:
	  xmas_fsm_state_mkFSMstate$D_IN = 5'd9;
      WILL_FIRE_RL_xmas_fsm_action_l51c32:
	  xmas_fsm_state_mkFSMstate$D_IN = 5'd10;
      WILL_FIRE_RL_xmas_fsm_action_l52c32:
	  xmas_fsm_state_mkFSMstate$D_IN = 5'd11;
      WILL_FIRE_RL_xmas_fsm_action_l53c32:
	  xmas_fsm_state_mkFSMstate$D_IN = 5'd12;
      WILL_FIRE_RL_xmas_fsm_action_l54c32:
	  xmas_fsm_state_mkFSMstate$D_IN = 5'd13;
      WILL_FIRE_RL_xmas_fsm_action_l55c32:
	  xmas_fsm_state_mkFSMstate$D_IN = 5'd14;
      WILL_FIRE_RL_xmas_fsm_action_l56c32:
	  xmas_fsm_state_mkFSMstate$D_IN = 5'd15;
      WILL_FIRE_RL_xmas_fsm_action_l57c32:
	  xmas_fsm_state_mkFSMstate$D_IN = 5'd16;
      WILL_FIRE_RL_xmas_fsm_action_l58c32:
	  xmas_fsm_state_mkFSMstate$D_IN = 5'd17;
      WILL_FIRE_RL_xmas_fsm_action_l59c32:
	  xmas_fsm_state_mkFSMstate$D_IN = 5'd18;
      WILL_FIRE_RL_xmas_fsm_action_l60c32:
	  xmas_fsm_state_mkFSMstate$D_IN = 5'd19;
      WILL_FIRE_RL_xmas_fsm_action_l61c32:
	  xmas_fsm_state_mkFSMstate$D_IN = 5'd20;
      WILL_FIRE_RL_xmas_fsm_action_l62c32:
	  xmas_fsm_state_mkFSMstate$D_IN = 5'd21;
      WILL_FIRE_RL_xmas_fsm_action_l63c32:
	  xmas_fsm_state_mkFSMstate$D_IN = 5'd22;
      WILL_FIRE_RL_xmas_fsm_action_l64c32:
	  xmas_fsm_state_mkFSMstate$D_IN = 5'd23;
      WILL_FIRE_RL_xmas_fsm_action_l65c32:
	  xmas_fsm_state_mkFSMstate$D_IN = 5'd24;
      WILL_FIRE_RL_xmas_fsm_action_l66c32:
	  xmas_fsm_state_mkFSMstate$D_IN = 5'd25;
      default: xmas_fsm_state_mkFSMstate$D_IN =
		   5'b01010 /* unspecified value */ ;
    endcase
  end
  assign xmas_fsm_state_mkFSMstate$EN =
	     WILL_FIRE_RL_xmas_fsm_idle_l40c27_1 ||
	     WILL_FIRE_RL_xmas_fsm_idle_l40c27 ||
	     WILL_FIRE_RL_xmas_fsm_action_l42c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l43c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l44c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l45c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l46c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l47c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l48c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l49c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l50c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l51c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l52c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l53c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l54c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l55c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l56c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l57c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l58c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l59c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l60c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l61c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l62c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l63c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l64c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l65c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l66c32 ;

  // submodule rule30
  assign rule30$start_a = a ;
  assign rule30$EN_start = CAN_FIRE_RL_compute ;
  assign rule30$EN_getResult = CAN_FIRE_RL_get_result ;

  // submodule uart_baudGen_rBaudCounter
  assign uart_baudGen_rBaudCounter$DATA_A = 16'd1 ;
  assign uart_baudGen_rBaudCounter$DATA_B = 16'h0 ;
  assign uart_baudGen_rBaudCounter$DATA_C = 16'h0 ;
  assign uart_baudGen_rBaudCounter$DATA_F = 16'd0 ;
  assign uart_baudGen_rBaudCounter$ADDA =
	     uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29 ;
  assign uart_baudGen_rBaudCounter$ADDB = 1'b0 ;
  assign uart_baudGen_rBaudCounter$SETC = 1'b0 ;
  assign uart_baudGen_rBaudCounter$SETF =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;

  // submodule uart_baudGen_rBaudTickCounter
  assign uart_baudGen_rBaudTickCounter$DATA_A = 3'd1 ;
  assign uart_baudGen_rBaudTickCounter$DATA_B = 3'h0 ;
  assign uart_baudGen_rBaudTickCounter$DATA_C = 3'h0 ;
  assign uart_baudGen_rBaudTickCounter$DATA_F = 3'h0 ;
  assign uart_baudGen_rBaudTickCounter$ADDA =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;
  assign uart_baudGen_rBaudTickCounter$ADDB = 1'b0 ;
  assign uart_baudGen_rBaudTickCounter$SETC = 1'b0 ;
  assign uart_baudGen_rBaudTickCounter$SETF = 1'b0 ;

  // submodule uart_fifoRecv
  assign uart_fifoRecv$D_IN =
	     { uart_vrRecvBuffer_7,
	       uart_vrRecvBuffer_6,
	       uart_vrRecvBuffer_5,
	       uart_vrRecvBuffer_4,
	       uart_vrRecvBuffer_3,
	       uart_vrRecvBuffer_2,
	       uart_vrRecvBuffer_1,
	       uart_vrRecvBuffer_0 } ;
  assign uart_fifoRecv$ENQ = CAN_FIRE_RL_uart_receive_stop_last_bit ;
  assign uart_fifoRecv$DEQ = uart_fifoRecv$EMPTY_N ;
  assign uart_fifoRecv$CLR = 1'b0 ;

  // submodule uart_fifoXmit
  always@(WILL_FIRE_RL_get_result or
	  rule30$getResult or
	  MUX_uart_fifoXmit$enq_1__SEL_2 or
	  MUX_uart_fifoXmit$enq_1__SEL_3 or
	  WILL_FIRE_RL_xmas_fsm_action_l64c32 or
	  WILL_FIRE_RL_xmas_fsm_action_l53c32 or
	  WILL_FIRE_RL_xmas_fsm_action_l54c32 or
	  WILL_FIRE_RL_xmas_fsm_action_l55c32 or
	  WILL_FIRE_RL_xmas_fsm_action_l42c32 or
	  WILL_FIRE_RL_xmas_fsm_action_l57c32 or
	  WILL_FIRE_RL_xmas_fsm_action_l48c32 or
	  MUX_uart_fifoXmit$enq_1__SEL_11 or
	  WILL_FIRE_RL_xmas_fsm_action_l43c32 or
	  WILL_FIRE_RL_xmas_fsm_action_l49c32 or
	  WILL_FIRE_RL_xmas_fsm_action_l62c32 or
	  MUX_uart_fifoXmit$enq_1__SEL_15 or
	  MUX_uart_fifoXmit$enq_1__SEL_16 or
	  MUX_uart_fifoXmit$enq_1__SEL_17 or
	  WILL_FIRE_RL_xmas_fsm_action_l46c32)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_get_result: uart_fifoXmit$D_IN = rule30$getResult;
      MUX_uart_fifoXmit$enq_1__SEL_2: uart_fifoXmit$D_IN = 8'h09;
      MUX_uart_fifoXmit$enq_1__SEL_3: uart_fifoXmit$D_IN = 8'h20;
      WILL_FIRE_RL_xmas_fsm_action_l64c32: uart_fifoXmit$D_IN = 8'h21;
      WILL_FIRE_RL_xmas_fsm_action_l53c32: uart_fifoXmit$D_IN = 8'h27;
      WILL_FIRE_RL_xmas_fsm_action_l54c32: uart_fifoXmit$D_IN = 8'h32;
      WILL_FIRE_RL_xmas_fsm_action_l55c32: uart_fifoXmit$D_IN = 8'h34;
      WILL_FIRE_RL_xmas_fsm_action_l42c32: uart_fifoXmit$D_IN = 8'h4D;
      WILL_FIRE_RL_xmas_fsm_action_l57c32: uart_fifoXmit$D_IN = 8'h53;
      WILL_FIRE_RL_xmas_fsm_action_l48c32: uart_fifoXmit$D_IN = 8'h58;
      MUX_uart_fifoXmit$enq_1__SEL_11: uart_fifoXmit$D_IN = 8'h61;
      WILL_FIRE_RL_xmas_fsm_action_l43c32: uart_fifoXmit$D_IN = 8'h65;
      WILL_FIRE_RL_xmas_fsm_action_l49c32: uart_fifoXmit$D_IN = 8'h6D;
      WILL_FIRE_RL_xmas_fsm_action_l62c32: uart_fifoXmit$D_IN = 8'h6F;
      MUX_uart_fifoXmit$enq_1__SEL_15: uart_fifoXmit$D_IN = 8'h72;
      MUX_uart_fifoXmit$enq_1__SEL_16: uart_fifoXmit$D_IN = 8'h73;
      MUX_uart_fifoXmit$enq_1__SEL_17: uart_fifoXmit$D_IN = 8'h74;
      WILL_FIRE_RL_xmas_fsm_action_l46c32: uart_fifoXmit$D_IN = 8'h79;
      default: uart_fifoXmit$D_IN = 8'b10101010 /* unspecified value */ ;
    endcase
  end
  assign uart_fifoXmit$ENQ =
	     WILL_FIRE_RL_get_result || WILL_FIRE_RL_xmas_fsm_action_l66c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l65c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l56c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l52c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l47c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l64c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l53c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l54c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l55c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l42c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l57c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l48c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l60c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l50c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l43c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l49c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l62c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l59c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l45c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l44c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l63c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l51c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l61c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l58c32 ||
	     WILL_FIRE_RL_xmas_fsm_action_l46c32 ;
  assign uart_fifoXmit$DEQ = CAN_FIRE_RL_uart_transmit_buffer_load ;
  assign uart_fifoXmit$CLR = 1'b0 ;

  // remaining internal signals
  assign _dor2uart_pwXmitCellCountReset$EN_wset =
	     WILL_FIRE_RL_uart_transmit_send_stop_bit2 ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit ||
	     WILL_FIRE_RL_uart_transmit_send_parity_bit ||
	     WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time ||
	     WILL_FIRE_RL_uart_transmit_send_start_bit ;
  assign uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_27___d29 =
	     uart_baudGen_rBaudCounter$Q_OUT + 16'd1 < 16'd27 ;
  assign x__h2985 = uart_rRecvCellCount + 4'd1 ;
  assign x__h4689 = uart_rRecvBitCount + 4'd1 ;
  assign x__h6445 = uart_rXmitCellCount + 4'd1 ;
  assign x__h6471 = uart_rXmitBitCount + 4'd1 ;
  assign xmas_fsm_abort_whas__57_AND_xmas_fsm_abort_wge_ETC___d302 =
	     (xmas_fsm_state_mkFSMstate == 5'd0 ||
	      xmas_fsm_state_mkFSMstate == 5'd25 ||
	      xmas_fsm_state_mkFSMstate == 5'd27) &&
	     (!xmas_fsm_start_reg_1 || xmas_fsm_state_fired) ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        a <= `BSV_ASSIGNMENT_DELAY 8'b0;
	op_mode <= `BSV_ASSIGNMENT_DELAY 1'd0;
	transmit_state <= `BSV_ASSIGNMENT_DELAY 2'd0;
	uart_rRecvData <= `BSV_ASSIGNMENT_DELAY 1'd1;
	xmas_fsm_start_reg <= `BSV_ASSIGNMENT_DELAY 1'd0;
	xmas_fsm_start_reg_1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	xmas_fsm_state_fired <= `BSV_ASSIGNMENT_DELAY 1'd0;
	xmas_fsm_state_mkFSMstate <= `BSV_ASSIGNMENT_DELAY 5'd0;
      end
    else
      begin
        if (a$EN) a <= `BSV_ASSIGNMENT_DELAY a$D_IN;
	if (op_mode$EN) op_mode <= `BSV_ASSIGNMENT_DELAY op_mode$D_IN;
	if (transmit_state$EN)
	  transmit_state <= `BSV_ASSIGNMENT_DELAY transmit_state$D_IN;
	if (uart_rRecvData$EN)
	  uart_rRecvData <= `BSV_ASSIGNMENT_DELAY uart_rRecvData$D_IN;
	if (xmas_fsm_start_reg$EN)
	  xmas_fsm_start_reg <= `BSV_ASSIGNMENT_DELAY xmas_fsm_start_reg$D_IN;
	if (xmas_fsm_start_reg_1$EN)
	  xmas_fsm_start_reg_1 <= `BSV_ASSIGNMENT_DELAY
	      xmas_fsm_start_reg_1$D_IN;
	if (xmas_fsm_state_fired$EN)
	  xmas_fsm_state_fired <= `BSV_ASSIGNMENT_DELAY
	      xmas_fsm_state_fired$D_IN;
	if (xmas_fsm_state_mkFSMstate$EN)
	  xmas_fsm_state_mkFSMstate <= `BSV_ASSIGNMENT_DELAY
	      xmas_fsm_state_mkFSMstate$D_IN;
      end
    if (uart_vrRecvBuffer_0$EN)
      uart_vrRecvBuffer_0 <= `BSV_ASSIGNMENT_DELAY uart_vrRecvBuffer_0$D_IN;
    if (uart_vrRecvBuffer_1$EN)
      uart_vrRecvBuffer_1 <= `BSV_ASSIGNMENT_DELAY uart_vrRecvBuffer_1$D_IN;
    if (uart_vrRecvBuffer_2$EN)
      uart_vrRecvBuffer_2 <= `BSV_ASSIGNMENT_DELAY uart_vrRecvBuffer_2$D_IN;
    if (uart_vrRecvBuffer_3$EN)
      uart_vrRecvBuffer_3 <= `BSV_ASSIGNMENT_DELAY uart_vrRecvBuffer_3$D_IN;
    if (uart_vrRecvBuffer_4$EN)
      uart_vrRecvBuffer_4 <= `BSV_ASSIGNMENT_DELAY uart_vrRecvBuffer_4$D_IN;
    if (uart_vrRecvBuffer_5$EN)
      uart_vrRecvBuffer_5 <= `BSV_ASSIGNMENT_DELAY uart_vrRecvBuffer_5$D_IN;
    if (uart_vrRecvBuffer_6$EN)
      uart_vrRecvBuffer_6 <= `BSV_ASSIGNMENT_DELAY uart_vrRecvBuffer_6$D_IN;
    if (uart_vrRecvBuffer_7$EN)
      uart_vrRecvBuffer_7 <= `BSV_ASSIGNMENT_DELAY uart_vrRecvBuffer_7$D_IN;
    if (uart_vrXmitBuffer_0$EN)
      uart_vrXmitBuffer_0 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_0$D_IN;
    if (uart_vrXmitBuffer_1$EN)
      uart_vrXmitBuffer_1 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_1$D_IN;
    if (uart_vrXmitBuffer_2$EN)
      uart_vrXmitBuffer_2 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_2$D_IN;
    if (uart_vrXmitBuffer_3$EN)
      uart_vrXmitBuffer_3 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_3$D_IN;
    if (uart_vrXmitBuffer_4$EN)
      uart_vrXmitBuffer_4 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_4$D_IN;
    if (uart_vrXmitBuffer_5$EN)
      uart_vrXmitBuffer_5 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_5$D_IN;
    if (uart_vrXmitBuffer_6$EN)
      uart_vrXmitBuffer_6 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_6$D_IN;
    if (uart_vrXmitBuffer_7$EN)
      uart_vrXmitBuffer_7 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_7$D_IN;
  end

  always@(posedge CLK or `BSV_RESET_EDGE RST_N)
  if (RST_N == `BSV_RESET_VALUE)
    begin
      uart_rRecvBitCount <= `BSV_ASSIGNMENT_DELAY 4'd0;
      uart_rRecvCellCount <= `BSV_ASSIGNMENT_DELAY 4'd0;
      uart_rRecvState <= `BSV_ASSIGNMENT_DELAY 3'd0;
      uart_rXmitBitCount <= `BSV_ASSIGNMENT_DELAY 4'd0;
      uart_rXmitCellCount <= `BSV_ASSIGNMENT_DELAY 4'd0;
      uart_rXmitDataOut <= `BSV_ASSIGNMENT_DELAY 1'd1;
      uart_rXmitState <= `BSV_ASSIGNMENT_DELAY 3'd0;
    end
  else
    begin
      if (uart_rRecvBitCount$EN)
	uart_rRecvBitCount <= `BSV_ASSIGNMENT_DELAY uart_rRecvBitCount$D_IN;
      if (uart_rRecvCellCount$EN)
	uart_rRecvCellCount <= `BSV_ASSIGNMENT_DELAY uart_rRecvCellCount$D_IN;
      if (uart_rRecvState$EN)
	uart_rRecvState <= `BSV_ASSIGNMENT_DELAY uart_rRecvState$D_IN;
      if (uart_rXmitBitCount$EN)
	uart_rXmitBitCount <= `BSV_ASSIGNMENT_DELAY uart_rXmitBitCount$D_IN;
      if (uart_rXmitCellCount$EN)
	uart_rXmitCellCount <= `BSV_ASSIGNMENT_DELAY uart_rXmitCellCount$D_IN;
      if (uart_rXmitDataOut$EN)
	uart_rXmitDataOut <= `BSV_ASSIGNMENT_DELAY uart_rXmitDataOut$D_IN;
      if (uart_rXmitState$EN)
	uart_rXmitState <= `BSV_ASSIGNMENT_DELAY uart_rXmitState$D_IN;
    end


  // handling of system tasks

endmodule  // mkRule30Driver

